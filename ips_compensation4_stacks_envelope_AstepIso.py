# -*- coding: utf-8 -*-
"""IPS_compensation4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SbSYUOgWFAERdEdDCtGQbS05TMEHVGhZ
"""


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Optimize CR and automatically save Stokes traces for the best stack,
PLUS optional progress tracking ("best-so-far" updates) during the grid search.

Requested cases:
  (1) LC/A/C (absorption-basis)
  (2) LC/A/C (transmission-basis +90°)
  (3) C/A/LC (transmission-basis +90°)

Outputs (under outdir):
  - summary.csv
  - best_stack_case*.json
  - stokes_white_case*.csv/.json
  - stokes_per_wavelength_case*.csv/.json
  - iso plots (*.png)

If --track_progress is enabled:
  - progress_case*.csv  (each row = when best CR updated)
  - progress_case*.json (same content)
  - progress_case*_CR.png (CR vs update index) if --progress_plot

Dependencies (same folder or importable):
  - ips_compensation_run_signedC.py
  - ips_stokes_trace.py
"""
import argparse
import json
from pathlib import Path
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd

import ips_compensation_run_signedC as ips
from ips_stokes_trace import trace_stokes_white, trace_stokes_per_wavelength


# -----------------------------
# User / model settings
# -----------------------------
def setup_model():
    ips.dn_LC = 0.1
    ips.d_LC  = 3.1e-6

    ips.USE_DN_DISPERSION = True
    ips.DN_SCALE = dict(ips.DN_SCALE_MATCHED)
    ips.WL_KEYS = ("B", "G", "R")
    ips.WL_WEIGHTS = {"B": 1.0, "G": 1.0, "R": 1.0}


# -----------------------------
# Utilities
# -----------------------------
def CR_from_stack(theta_deg: float, phi_deg: float, stack, c1, c2) -> float:
    T = float(ips.Tleak_stack_scalar(float(theta_deg), float(phi_deg), stack, c1=c1, c2=c2))
    return float(ips.CR_from_Tleak(T))

def global_minCR(stack, c1, c2, theta_max=60.0, dtheta=5.0, dphi=5.0, theta_min_eval=10.0):
    thetas = np.arange(0.0, theta_max + 1e-9, dtheta)
    phis   = np.arange(0.0, 360.0, dphi)
    CR = np.zeros((len(thetas), len(phis)))
    for i, th in enumerate(thetas):
        for j, ph in enumerate(phis):
            CR[i, j] = CR_from_stack(th, ph, stack, c1, c2)
    reg = CR[thetas >= theta_min_eval, :]
    return float(np.min(reg)), float(np.percentile(reg, 5))

def save_iso(stack, title: str, out_path: Path, c1, c2, theta_max=60.0, dtheta=5.0, dphi=5.0):
    thetas, phis, CR = ips.compute_CR_grid(stack, c1, c2, theta_max=theta_max, dtheta=dtheta, dphi=dphi)
    ips.plot_isocontrast_polar(
        thetas, phis, CR,
        title=title,
        out_path=str(out_path),
        theta_ticks=[0,10,20,30,40,50,60]
    )

def dump_stack_json(stack, out_path: Path):
    out_path.write_text(json.dumps(stack, indent=2), encoding="utf-8")

def save_stokes_traces(case_tag: str, theta_deg: float, phi_deg: float, stack, c1, c2,
                       basis: str, outdir: Path):
    """
    Save:
      - white-averaged trace (CSV+JSON)
      - per-wavelength trace (CSV+JSON)
    """
    white_rows = trace_stokes_white(theta_deg, phi_deg, stack, c1=c1, c2=c2, basis=basis)
    dfw = pd.DataFrame(white_rows)
    dfw.to_csv(outdir / f"stokes_white_{case_tag}.csv", index=False)
    (outdir / f"stokes_white_{case_tag}.json").write_text(json.dumps(white_rows, indent=2), encoding="utf-8")

    pts = trace_stokes_per_wavelength(theta_deg, phi_deg, stack, c1=c1, c2=c2, basis=basis)
    rows = [p.as_dict() for p in pts]
    dfp = pd.DataFrame(rows)
    dfp.to_csv(outdir / f"stokes_per_wavelength_{case_tag}.csv", index=False)
    (outdir / f"stokes_per_wavelength_{case_tag}.json").write_text(json.dumps(rows, indent=2), encoding="utf-8")

def flatten_white_stokes(white_rows: List[Dict[str, float]]) -> Dict[str, float]:
    """
    Convert trace_stokes_white output into flat columns:
      s1_POL_in, s2_POL_in, s3_POL_in, ... s1_el#0_LC, ...
    """
    flat: Dict[str, float] = {}
    for r in white_rows:
        lab = str(r["label"])
        flat[f"S0_{lab}"] = float(r["S0_sum"])
        flat[f"s1_{lab}"] = float(r["s1"])
        flat[f"s2_{lab}"] = float(r["s2"])
        flat[f"s3_{lab}"] = float(r["s3"])
    return flat

def save_progress(case_tag: str, progress_rows: List[Dict], outdir: Path, do_plot: bool):
    (outdir / f"progress_{case_tag}.json").write_text(json.dumps(progress_rows, indent=2), encoding="utf-8")
    df = pd.DataFrame(progress_rows)
    df.to_csv(outdir / f"progress_{case_tag}.csv", index=False)

    if do_plot and len(df) >= 2:
        import matplotlib.pyplot as plt
        fig = plt.figure()
        plt.plot(df["update_idx"], df["best_CR"])
        plt.xlabel("update_idx (best-so-far updates)")
        plt.ylabel("best_CR at target")
        plt.title(f"Progress: {case_tag} (best CR updates)")
        fig.savefig(outdir / f"progress_{case_tag}_CR.png", dpi=200, bbox_inches="tight")
        plt.close(fig)


# -----------------------------
# Layer builders
# -----------------------------
def build_LC(lc_basis: str, pol_in_deg: float, relLC_deg: float):
    az = 0.0 if lc_basis == "abs" else 90.0
    axis_LC = ips.rotz_deg(ips.axis_from_azimuth_deg(az), pol_in_deg + relLC_deg)
    return {
        "type": "LC",
        "axis": axis_LC.tolist(),
        "d": float(ips.d_LC),
        "no": ips.NO_BASE,
        "ne": ips.ne_from_dn(ips.NO_BASE, float(ips.dn_LC)),
    }

def build_A(A_scale: float, A_base_deg: float, pol_out_deg: float, relA_deg: float, A_kind: str):
    axis_A = ips.rotz_deg(ips.axis_from_azimuth_deg(float(A_base_deg)), pol_out_deg + relA_deg)
    Re_each_m = (ips.RE_A_EACH_BASE_NM * 1e-9) * float(A_scale)
    dnA = float(ips.dn_upperA) if A_kind == "upper" else float(ips.dn_lowerA)
    dA = Re_each_m / dnA if float(A_scale) != 0 else 0.0
    return {
        "type": "A",
        "axis": axis_A.tolist(),
        "d": float(dA),
        "no": ips.NO_BASE,
        "ne": ips.ne_from_dn(ips.NO_BASE, dnA),
    }

def build_C(ReC_nm_signed: float):
    ReC = float(ReC_nm_signed)
    if ReC == 0:
        return None
    sgn = 1.0 if ReC >= 0 else -1.0
    dnC = float(ips.dn_C)
    dC_um = abs(ReC) / (dnC * 1000.0)
    return {
        "type": "C",
        "axis": [0, 0, 1],
        "d": float(dC_um) * 1e-6,
        "no": ips.NO_BASE,
        "ne": ips.ne_from_dn(ips.NO_BASE, dnC * sgn),
    }


# -----------------------------
# Stack definitions
# -----------------------------
def stack_LC_A_C(lc_basis: str, A_scale: float, ReC_nm: float,
                 pol_in_deg: float, pol_out_deg: float, relA_deg: float, relLC_deg: float,
                 A_base_deg=90.0, A_kind="upper"):
    LC = build_LC(lc_basis, pol_in_deg, relLC_deg)
    A  = build_A(A_scale, A_base_deg, pol_out_deg, relA_deg, A_kind)
    C  = build_C(ReC_nm)
    st = [LC, A]
    if C is not None:
        st.append(C)
    return st

def stack_C_A_LC_trans(A_scale: float, ReC_nm: float,
                       pol_in_deg: float, pol_out_deg: float, relA_deg: float, relLC_deg: float,
                       A_base_deg=0.0, A_kind="upper"):
    LC = build_LC("tran", pol_in_deg, relLC_deg)
    A  = build_A(A_scale, A_base_deg, pol_out_deg, relA_deg, A_kind)
    C  = build_C(ReC_nm)
    st = []
    if C is not None:
        st.append(C)
    st.append(A)
    st.append(LC)
    return st



def build_A_bot(A_scale: float, pol_in_deg: float, relA_deg: float, A_kind: str):
    """
    Bottom A-plate whose in-plane axis follows input-side rotation (pol_in).
    Convention matches the tex definitions used previously:
      alpha_A,bot = pol_in + relA   (base = 0 deg)
    """
    axis_A = ips.rotz_deg(ips.axis_from_azimuth_deg(0.0), pol_in_deg + relA_deg)
    Re_each_m = (ips.RE_A_EACH_BASE_NM * 1e-9) * float(A_scale)
    dnA = float(ips.dn_upperA) if A_kind == "upper" else float(ips.dn_lowerA)
    dA = Re_each_m / dnA if float(A_scale) != 0 else 0.0
    return {
        "type": "A",
        "axis": axis_A.tolist(),
        "d": float(dA),
        "no": ips.NO_BASE,
        "ne": ips.ne_from_dn(ips.NO_BASE, dnA),
    }


def stack_C_A_LC_A_C(lc_basis: str,
                     A_scale: float, ReC_nm: float,
                     pol_in_deg: float, pol_out_deg: float,
                     relA_deg: float, relLC_deg: float,
                     A_kind: str = "upper"):
    """
    Symmetric 5-layer stack:
      C / A(bot) / LC / A(top) / C

    - C is uniaxial along z, signed ReC (same for both sides).
    - A(bot) axis follows pol_in:  alpha_A,bot = pol_in + relA  (base=0)
    - A(top) axis follows pol_out: alpha_A,top = 90 + pol_out + relA (base=90)
    - LC axis follows pol_in with lc_basis ('abs' or 'tran'): alpha_LC = pol_in + relLC (+90 if tran basis)
    """
    C1 = build_C(ReC_nm)
    C2 = build_C(ReC_nm)
    A_bot = build_A_bot(A_scale, pol_in_deg, relA_deg, A_kind)
    LC = build_LC(lc_basis, pol_in_deg, relLC_deg)
    A_top = build_A(A_scale, 90.0, pol_out_deg, relA_deg, A_kind)

    st = []
    if C1 is not None:
        st.append(C1)
    st.append(A_bot)
    st.append(LC)
    st.append(A_top)
    if C2 is not None:
        st.append(C2)
    return st

# -----------------------------
# Optimizer with optional progress tracking
# -----------------------------
def grid_optimize(builder_fn,
                  A_scales: np.ndarray,
                  ReC_nms: np.ndarray,
                  A_bases: List[float],
                  A_kinds: List[str],
                  theta_tgt: float,
                  phi_tgt: float,
                  c1, c2,
                  track_progress: bool,
                  progress_stride: int,
                  progress_limit: int,
                  stokes_theta: float,
                  stokes_phi: float,
                  stokes_basis: str) -> Tuple[Dict, List[Dict]]:
    best = {"CR": -1.0}
    progress: List[Dict] = []
    update_idx = 0

    for A_base in A_bases:
        for A_kind in A_kinds:
            for A_scale in A_scales:
                for ReC in ReC_nms:
                    st = builder_fn(A_scale, ReC, A_base, A_kind)
                    cr = CR_from_stack(theta_tgt, phi_tgt, st, c1, c2)
                    if cr > best["CR"]:
                        best = {
                            "CR": float(cr),
                            "A_scale": float(A_scale),
                            "ReC_nm": float(ReC),
                            "A_base_deg": float(A_base),
                            "A_kind": str(A_kind),
                            "stack": st,
                        }

                        if track_progress:
                            # Record every progress_stride-th update
                            if (update_idx % max(progress_stride, 1)) == 0:
                                white_rows = trace_stokes_white(stokes_theta, stokes_phi, st, c1=c1, c2=c2, basis=stokes_basis)
                                row = {
                                    "update_idx": int(update_idx),
                                    "best_CR": float(cr),
                                    "A_scale": float(A_scale),
                                    "ReC_nm": float(ReC),
                                    "A_base_deg": float(A_base),
                                    "A_kind": str(A_kind),
                                }
                                row.update(flatten_white_stokes(white_rows))
                                progress.append(row)

                                if progress_limit > 0 and len(progress) >= progress_limit:
                                    return best, progress

                        update_idx += 1

    return best, progress



def envelope_over_A(builder_fn, A_scales: np.ndarray, ReC_nms: np.ndarray,
                    A_bases, A_kinds,
                    theta_tgt: float, phi_tgt: float, c1, c2, outdir: Path, tag: str):
    """
    For each A_scale, choose the best combination over (A_base, A_kind, ReC) on the provided grids,
    and record the maximum CR. Export CSV and plots.

    X-axis is ReA_nm = RE_A_EACH_BASE_NM * A_scale.
    """
    import matplotlib.pyplot as plt
    rows = []
    global_best = -1.0
    global_best_row = None

    for A_scale in A_scales:
        best_cr = -1.0
        best = {"ReC_nm": None, "A_base_deg": None, "A_kind": None}
        for A_base in A_bases:
            for A_kind in A_kinds:
                for ReC in ReC_nms:
                    st = builder_fn(float(A_scale), float(ReC), float(A_base), str(A_kind))
                    cr = float(CR_from_stack(float(theta_tgt), float(phi_tgt), st, c1, c2))
                    if cr > best_cr:
                        best_cr = cr
                        best = {"ReC_nm": float(ReC), "A_base_deg": float(A_base), "A_kind": str(A_kind)}
        ReA_nm = float(ips.RE_A_EACH_BASE_NM) * float(A_scale)
        row = {
            "A_scale": float(A_scale),
            "ReA_nm": ReA_nm,
            "best_CR": float(best_cr),
            "best_ReC_nm": float(best["ReC_nm"]),
            "best_A_base_deg": float(best["A_base_deg"]),
            "best_A_kind": str(best["A_kind"]),
        }
        rows.append(row)
        if best_cr > global_best:
            global_best = best_cr
            global_best_row = row

    # add relative columns
    for r in rows:
        r["CR_rel_to_global_best"] = float(r["best_CR"] / global_best) if global_best > 0 else float("nan")
        r["CR_loss_pct_vs_best"] = float((1.0 - r["CR_rel_to_global_best"]) * 100.0) if global_best > 0 else float("nan")

    df = pd.DataFrame(rows).sort_values("ReA_nm").reset_index(drop=True)
    out_csv = outdir / f"A_envelope_{tag}.csv"
    df.to_csv(out_csv, index=False)

    # plot: ReA_nm vs best_CR
    fig = plt.figure(figsize=(6.8, 3.8), dpi=200)
    ax = fig.add_subplot(111)
    ax.plot(df["ReA_nm"].values, df["best_CR"].values, marker="o", ms=2.5, lw=1.0)
    ax.set_xlabel("ReA (nm)")
    ax.set_ylabel("max CR (optimized over ReC grid)")
    ax.set_yscale("log")
    ax.grid(True, which="both", ls=":")
    if global_best_row is not None:
        ax.set_title(f"{tag} envelope: best at ReA={global_best_row['ReA_nm']:.2f} nm (A={global_best_row['A_scale']:.2f}), ReC={global_best_row['best_ReC_nm']:.0f} nm")
    else:
        ax.set_title(f"{tag} envelope: max CR vs ReA")
    fig.tight_layout()
    fig.savefig(outdir / f"A_envelope_{tag}_CR.png")
    plt.close(fig)

    # plot: relative vs best
    fig = plt.figure(figsize=(6.8, 3.8), dpi=200)
    ax = fig.add_subplot(111)
    ax.plot(df["ReA_nm"].values, df["CR_rel_to_global_best"].values, marker="o", ms=2.5, lw=1.0)
    ax.set_xlabel("ReA (nm)")
    ax.set_ylabel("CR / global_best_CR")
    ax.set_ylim(0.0, 1.05)
    ax.grid(True, which="both", ls=":")
    ax.set_title(f"{tag} envelope: relative performance vs global best")
    fig.tight_layout()
    fig.savefig(outdir / f"A_envelope_{tag}_rel_to_best.png")
    plt.close(fig)

    (outdir / f"A_envelope_{tag}_best.json").write_text(
        json.dumps({"global_best_CR": global_best, "global_best": global_best_row, "csv": out_csv.name}, indent=2),
        encoding="utf-8"
    )
    return df



def export_progress_iso(tag: str, progress_csv: Path, outdir: Path, stride: int,
                        builder_kind: str, pol_in: float, pol_out: float, relA: float, relLC: float):
    """
    Export ISO plots for selected progress rows into:
      outdir/iso_progress_<tag>/
    with an index.csv listing parameters and filenames.
    builder_kind: 'LC_AC_abs' | 'LC_AC_tran' | 'CA_LC_tran' | 'CA_LC_AC_abs' | 'CA_LC_AC_tran'
    """
    if stride <= 0:
        return
    if not progress_csv.exists():
        return
    import pandas as pd
    df = pd.read_csv(progress_csv)
    if len(df) == 0:
        return

    sub = outdir / f"iso_progress_{tag}"
    sub.mkdir(parents=True, exist_ok=True)

    idxs = list(range(0, len(df), stride))
    if (len(df) - 1) not in idxs:
        idxs.append(len(df) - 1)

    setup_model()
    c1, c2 = ips.pol_axes()

    rows = []
    for i in idxs:
        r = df.iloc[i]
        upd = int(r["update_idx"])
        A_scale = float(r["A_scale"]); ReC_nm = float(r["ReC_nm"])
        A_base = float(r["A_base_deg"]); A_kind = str(r["A_kind"])

        if builder_kind == "LC_AC_abs":
            stack = stack_LC_A_C("abs", A_scale, ReC_nm, pol_in, pol_out, relA, relLC, A_base, A_kind)
        elif builder_kind == "LC_AC_tran":
            stack = stack_LC_A_C("tran", A_scale, ReC_nm, pol_in, pol_out, relA, relLC, A_base, A_kind)
        elif builder_kind == "CA_LC_tran":
            stack = stack_C_A_LC_trans(A_scale, ReC_nm, pol_in, pol_out, relA, relLC, A_base, A_kind)
        elif builder_kind == "CA_LC_AC_abs":
            stack = stack_C_A_LC_A_C("abs", A_scale, ReC_nm, pol_in, pol_out, relA, relLC, A_kind=A_kind)
        elif builder_kind == "CA_LC_AC_tran":
            stack = stack_C_A_LC_A_C("tran", A_scale, ReC_nm, pol_in, pol_out, relA, relLC, A_kind=A_kind)
        else:
            continue

        title = f"ISO-CR ({tag} progress u{upd:03d}: A_scale={A_scale:.2f}, ReC={ReC_nm:.0f}nm)"
        fn = f"iso_{tag}_u{upd:03d}.png"
        save_iso(stack, title, sub / fn, c1, c2)
        rows.append({**{k: r[k] for k in r.index}, "png": fn})

    pd.DataFrame(rows).to_csv(sub / "index.csv", index=False)



def export_Astep_iso_from_envelope(tag: str, envelope_csv: Path, outdir: Path, stride: int,
                                  builder_kind: str, pol_in: float, pol_out: float, relA: float, relLC: float,
                                  theta_max: float = 60.0, dtheta: float = 5.0, dphi: float = 5.0):
    """
    Export ISO plots for each A-step best point recorded in A_envelope_<tag>.csv.

    This is independent from progress logging: even if the global best is not updated,
    ISO plots are generated per A_scale step (optionally subsampled by stride).

    Outputs:
      outdir/iso_Astep_<tag>/
        iso_<tag>_A###.png
        index.csv (A_scale, best_ReC_nm, best_CR, etc + png)
    """
    if stride <= 0:
        return
    if not envelope_csv.exists():
        return
    import pandas as pd

    df = pd.read_csv(envelope_csv)
    if len(df) == 0:
        return

    sub = outdir / f"iso_Astep_{tag}"
    sub.mkdir(parents=True, exist_ok=True)

    idxs = list(range(0, len(df), stride))
    if (len(df) - 1) not in idxs:
        idxs.append(len(df) - 1)

    setup_model()
    c1, c2 = ips.pol_axes()

    rows = []
    for i in idxs:
        r = df.iloc[i]
        A_scale = float(r["A_scale"])
        ReC_nm = float(r["best_ReC_nm"])
        A_base = float(r.get("best_A_base_deg", 0.0))
        A_kind = str(r.get("best_A_kind", "upper"))
        best_CR = float(r.get("best_CR", float("nan")))
        ReA_nm = float(r.get("ReA_nm", float(ips.RE_A_EACH_BASE_NM) * A_scale))

        if builder_kind == "LC_AC_abs":
            stack = stack_LC_A_C("abs", A_scale, ReC_nm, pol_in, pol_out, relA, relLC,
                                 A_base_deg=A_base, A_kind=A_kind)
        elif builder_kind == "LC_AC_tran":
            stack = stack_LC_A_C("tran", A_scale, ReC_nm, pol_in, pol_out, relA, relLC,
                                 A_base_deg=A_base, A_kind=A_kind)
        elif builder_kind == "CA_LC_tran":
            stack = stack_C_A_LC_trans(A_scale, ReC_nm, pol_in, pol_out, relA, relLC,
                                       A_base_deg=A_base, A_kind=A_kind)
        elif builder_kind == "CA_LC_AC_abs":
            stack = stack_C_A_LC_A_C("abs", A_scale, ReC_nm, pol_in, pol_out, relA, relLC,
                                     A_kind=A_kind)
        elif builder_kind == "CA_LC_AC_tran":
            stack = stack_C_A_LC_A_C("tran", A_scale, ReC_nm, pol_in, pol_out, relA, relLC,
                                     A_kind=A_kind)
        else:
            continue

        title = f"ISO-CR ({tag} A-step i{i:03d}: A_scale={A_scale:.2f} (ReA={ReA_nm:.1f}nm), ReC={ReC_nm:.0f}nm, CR={best_CR:.1f})"
        fn = f"iso_{tag}_A{i:03d}.png"
        save_iso(stack, title, sub / fn, c1, c2, theta_max=float(theta_max), dtheta=float(dtheta), dphi=float(dphi))
        rows.append({
            "A_step_idx": int(i),
            "A_scale": A_scale,
            "ReA_nm": ReA_nm,
            "best_CR": best_CR,
            "best_ReC_nm": ReC_nm,
            "best_A_base_deg": A_base,
            "best_A_kind": A_kind,
            "png": fn,
        })

    pd.DataFrame(rows).to_csv(sub / "index.csv", index=False)


def main():
    p = argparse.ArgumentParser()
    p.add_argument("--outdir", type=str, default="out_opt", help="output directory")
    p.add_argument("--theta", type=float, default=30.0, help="target theta (deg) for optimization")
    p.add_argument("--phi", type=float, default=45.0, help="target phi (deg) for optimization")
    p.add_argument("--pol_in", type=float, default=0.0)
    p.add_argument("--pol_out", type=float, default=0.0)
    p.add_argument("--relA", type=float, default=0.25)
    p.add_argument("--relLC", type=float, default=0.25)

    # search ranges
    p.add_argument("--Amin", type=float, default=0.60)
    p.add_argument("--Amax", type=float, default=1.40)
    p.add_argument("--Ad", type=float, default=0.05)
    p.add_argument("--ReCmin", type=float, default=-280.0)
    p.add_argument("--ReCmax", type=float, default=280.0)
    p.add_argument("--ReCd", type=float, default=20.0)

    # Stokes trace settings (for best + progress)
    p.add_argument("--stokes_theta", type=float, default=None, help="theta for Stokes trace (default: --theta)")
    p.add_argument("--stokes_phi", type=float, default=None, help="phi for Stokes trace (default: --phi)")
    p.add_argument("--stokes_basis", type=str, default="pol_in", choices=["lab", "pol_in", "pol_out"],
                   help="basis for Stokes computation (recommended: pol_in)")

    # Stack selection
    p.add_argument("--stack", type=str, default="all",
                   choices=["all", "LC_AC_abs", "LC_AC_tran", "CA_LC_tran", "CA_LC_AC_abs", "CA_LC_AC_tran",
                            "case1", "case2", "case3"],
                   help="which stack(s) to run (canonical): all/LC_AC_abs/LC_AC_tran/CA_LC_tran/CA_LC_AC_abs/CA_LC_AC_tran (aliases: case1/case2/case3)")
    p.add_argument("--export_envelope", action="store_true",
                   help="export per-ReA envelope CSV/plots for selected stack(s)")

    p.add_argument("--export_Astep_iso", action="store_true",
                       help="export ISO plots per A-step best point (requires per-ReA envelope; will compute if needed)")
    p.add_argument("--Astep_iso_stride", type=int, default=1,
                       help="subsample A-step ISO export every N envelope rows (default: 1)")
    p.add_argument("--Astep_iso_theta_max", type=float, default=60.0,
                       help="theta_max for A-step ISO plots")
    p.add_argument("--Astep_iso_dtheta", type=float, default=5.0,
                       help="dtheta for A-step ISO plots (coarser = faster)")
    p.add_argument("--Astep_iso_dphi", type=float, default=5.0,
                       help="dphi for A-step ISO plots (coarser = faster)")
    p.add_argument("--skip_iso", action="store_true", help="skip ISO plot generation (faster)")
    p.add_argument("--skip_stokes", action="store_true", help="skip Stokes trace exports (faster)")
    p.add_argument("--skip_summary", action="store_true", help="skip summary.csv generation (faster)")
    p.add_argument("--load_best_from", type=str, default=None,
                   help="if set, skip optimization and load best_stack_*.json from this directory for plotting/export")

    # Progress tracking
    p.add_argument("--track_progress", action="store_true", help="save best-so-far updates during the search")
    p.add_argument("--progress_stride", type=int, default=1, help="log every N-th best update (default: 1)")
    p.add_argument("--progress_iso_stride", type=int, default=0,
                   help="if >0, export ISO plots for progress updates every N rows (creates iso_progress_<tag>/)")
    p.add_argument("--progress_limit", type=int, default=0, help="max number of progress rows (0 = no limit)")
    p.add_argument("--progress_plot", action="store_true", help="save CR-vs-update plot PNG")

    args, _unknown = p.parse_known_args()  # ignore -f from notebooks

    setup_model()
    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    st_theta = float(args.theta if args.stokes_theta is None else args.stokes_theta)
    st_phi   = float(args.phi   if args.stokes_phi   is None else args.stokes_phi)

    # (Notebook override removed)

    c1, c2 = ips.pol_axes(float(args.pol_in), float(args.pol_out))

    A_scales = np.round(np.arange(args.Amin, args.Amax + 1e-9, args.Ad), 4)
    ReC_nms  = np.arange(args.ReCmin, args.ReCmax + 1e-9, args.ReCd)

    LC_only_abs  = [build_LC("abs",  float(args.pol_in), float(args.relLC))]
    LC_only_tran = [build_LC("tran", float(args.pol_in), float(args.relLC))]

    # (1) LC/A/C absorption basis (fixed UA-like A: base=90, upper)
    def builder_1(A_scale, ReC, A_base, A_kind):
        return stack_LC_A_C(
            lc_basis="abs",
            A_scale=A_scale,
            ReC_nm=ReC,
            pol_in_deg=float(args.pol_in),
            pol_out_deg=float(args.pol_out),
            relA_deg=float(args.relA),
            relLC_deg=float(args.relLC),
            A_base_deg=A_base,
            A_kind=A_kind,
        )
    # -----------------------------
    # Run selected stacks
    # -----------------------------
    selected = str(args.stack).strip()

    # canonicalize legacy aliases
    alias_map = {"case1": "LC_AC_abs", "case2": "LC_AC_tran", "case3": "CA_LC_tran"}
    if selected in alias_map:
        selected = alias_map[selected]

    results = {}   # tag -> (best, prog)
    summary_rows = []

    def add_summary(label: str, best: dict, lc_only_stack: list):
        base3045 = CR_from_stack(float(args.theta), float(args.phi), lc_only_stack, c1, c2)
        base7045 = CR_from_stack(70.0, 45.0, lc_only_stack, c1, c2)
        base00   = CR_from_stack(0.0, 0.0, lc_only_stack, c1, c2)
        gmin_b, g5_b = global_minCR(lc_only_stack, c1, c2)

        st_best = best["stack"]
        best3045 = CR_from_stack(float(args.theta), float(args.phi), st_best, c1, c2)
        best7045 = CR_from_stack(70.0, 45.0, st_best, c1, c2)
        best00   = CR_from_stack(0.0, 0.0, st_best, c1, c2)
        gmin_s, g5_s = global_minCR(st_best, c1, c2)

        return {
            "case": label,
            "LC_only CR(30,45)": base3045,
            "best CR(30,45)": best3045,
            "improve vs LC": best3045 / base3045 if base3045 > 0 else np.nan,
            "best A_scale": best.get("A_scale"),
            "best ReC_nm": best.get("ReC_nm"),
            "best A_base_deg": best.get("A_base_deg"),
            "best A_kind": best.get("A_kind"),
            "LC_only CR(70,45)": base7045,
            "best CR(70,45)": best7045,
            "LC_only CR00": base00,
            "best CR00": best00,
            "LC_only global minCR": gmin_b,
            "best global minCR": gmin_s,
            "LC_only global p5CR": g5_b,
            "best global p5CR": g5_s,
        }

    # --- Define builders and metadata ---
    def builder_case1(A_scale, ReC, A_base, A_kind):
        return stack_LC_A_C(
            lc_basis="abs",
            A_scale=A_scale, ReC_nm=ReC,
            pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
            relA_deg=float(args.relA), relLC_deg=float(args.relLC),
            A_base_deg=A_base, A_kind=A_kind
        )

    def builder_case2(A_scale, ReC, A_base, A_kind):
        return stack_LC_A_C(
            lc_basis="tran",
            A_scale=A_scale, ReC_nm=ReC,
            pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
            relA_deg=float(args.relA), relLC_deg=float(args.relLC),
            A_base_deg=A_base, A_kind=A_kind
        )

    def builder_case3(A_scale, ReC, A_base, A_kind):
        return stack_C_A_LC_trans(
            A_scale=A_scale, ReC_nm=ReC,
            pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
            relA_deg=float(args.relA), relLC_deg=float(args.relLC),
            A_base_deg=A_base, A_kind=A_kind
        )

    def builder_CA_LC_AC_abs(A_scale, ReC, A_base, A_kind):
        # A_base is unused (fixed 0/90), kept for signature compatibility
        return stack_C_A_LC_A_C(
            lc_basis="abs",
            A_scale=A_scale, ReC_nm=ReC,
            pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
            relA_deg=float(args.relA), relLC_deg=float(args.relLC),
            A_kind=A_kind
        )

    def builder_CA_LC_AC_tran(A_scale, ReC, A_base, A_kind):
        return stack_C_A_LC_A_C(
            lc_basis="tran",
            A_scale=A_scale, ReC_nm=ReC,
            pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
            relA_deg=float(args.relA), relLC_deg=float(args.relLC),
            A_kind=A_kind
        )

    # LC-only stacks for ISO comparison
    LC_only_abs  = stack_LC_A_C("abs",  A_scale=0.0, ReC_nm=0.0,
                                pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
                                relA_deg=float(args.relA), relLC_deg=float(args.relLC))
    LC_only_tran = stack_LC_A_C("tran", A_scale=0.0, ReC_nm=0.0,
                                pol_in_deg=float(args.pol_in), pol_out_deg=float(args.pol_out),
                                relA_deg=float(args.relA), relLC_deg=float(args.relLC))

    case_defs = {
        "LC_AC_abs": dict(label="LC/A/C (abs)", tag="LC_AC_abs", builder=builder_case1,
                          A_bases=[90.0], A_kinds=["upper"], lc_only=LC_only_abs),
        "LC_AC_tran": dict(label="LC/A/C (tran)", tag="LC_AC_tran", builder=builder_case2,
                           A_bases=[0.0, 90.0], A_kinds=["upper", "lower"], lc_only=LC_only_tran),
        "CA_LC_tran": dict(label="C/A/LC (tran)", tag="CA_LC_tran", builder=builder_case3,
                           A_bases=[0.0, 90.0], A_kinds=["upper", "lower"], lc_only=LC_only_tran),
        "CA_LC_AC_abs": dict(label="C/A/LC/A/C (abs)", tag="CA_LC_AC_abs", builder=builder_CA_LC_AC_abs,
                             A_bases=[0.0], A_kinds=["upper", "lower"], lc_only=LC_only_abs),
        "CA_LC_AC_tran": dict(label="C/A/LC/A/C (tran)", tag="CA_LC_AC_tran", builder=builder_CA_LC_AC_tran,
                              A_bases=[0.0], A_kinds=["upper", "lower"], lc_only=LC_only_tran),
    }

    keys_to_run = []
    if selected == "all":
        keys_to_run = ["LC_AC_abs", "LC_AC_tran", "CA_LC_tran"]
    else:
        keys_to_run = [selected]

    # --- run grid optimize per selected case (or load existing best stacks) ---
    if args.load_best_from is not None:
        load_dir = Path(args.load_best_from)
        for key in keys_to_run:
            cd = case_defs[key]
            best_path = load_dir / f"best_stack_{cd['tag']}.json"
            best = json.loads(best_path.read_text(encoding='utf-8'))
            prog = []
            results[key] = (best, prog)
            # envelope / A-step ISO (optional)
            if bool(args.export_envelope) or bool(args.export_Astep_iso):
                envelope_over_A(cd['builder'], A_scales, ReC_nms,
                                cd['A_bases'], cd['A_kinds'],
                                float(args.theta), float(args.phi), c1, c2, outdir, cd['tag'])
                if bool(args.export_Astep_iso):
                    export_Astep_iso_from_envelope(
                        tag=cd['tag'],
                        envelope_csv=outdir / f"A_envelope_{cd['tag']}.csv",
                        outdir=outdir,
                        stride=int(args.Astep_iso_stride),
                        builder_kind=cd['tag'],
                        pol_in=float(args.pol_in), pol_out=float(args.pol_out),
                        relA=float(args.relA), relLC=float(args.relLC),
                        theta_max=float(args.Astep_iso_theta_max),
                        dtheta=float(args.Astep_iso_dtheta),
                        dphi=float(args.Astep_iso_dphi),
                    )
        # Note: progress logs are not regenerated in load mode.
    else:
        for key in keys_to_run:
            cd = case_defs[key]
            print(f"\n=== Running {cd['label']} ===")
            best, prog = grid_optimize(
            cd["builder"],
            A_scales=A_scales,
            ReC_nms=ReC_nms,
            A_bases=cd["A_bases"],
            A_kinds=cd["A_kinds"],
            theta_tgt=float(args.theta),
            phi_tgt=float(args.phi),
            c1=c1, c2=c2,
            track_progress=bool(args.track_progress),
            progress_stride=int(args.progress_stride),
            progress_limit=int(args.progress_limit),
            stokes_theta=st_theta,
            stokes_phi=st_phi,
            stokes_basis=str(args.stokes_basis),
            )
            results[key] = (best, prog)

            if bool(args.track_progress):
                save_progress(cd["tag"], prog, outdir, bool(args.progress_plot))
                # progress ISO (optional)
                if int(args.progress_iso_stride) > 0:
                    export_progress_iso(
                        tag=cd["tag"],
                        progress_csv=outdir / f"progress_{cd['tag']}.csv",
                        outdir=outdir,
                        stride=int(args.progress_iso_stride),
                        builder_kind=cd["tag"],
                        pol_in=float(args.pol_in), pol_out=float(args.pol_out),
                        relA=float(args.relA), relLC=float(args.relLC),
                    )
            # save best stack json (same naming convention)
            (outdir / f"best_stack_{cd['tag']}.json").write_text(json.dumps(best, indent=2), encoding="utf-8")
            # backward-compatible aliases
            alias_out = {"LC_AC_abs":"case1","LC_AC_tran":"case2","CA_LC_tran":"case3"}.get(cd["tag"])
            if alias_out is not None:
                # best stack
                (outdir / f"best_stack_{alias_out}.json").write_text(json.dumps(best, indent=2), encoding="utf-8")
                # progress
                for suf in [".csv", ".json", "_CR.png"]:
                    src = outdir / f"progress_{cd['tag']}{suf}"
                    dst = outdir / f"progress_{alias_out}{suf}"
                    if src.exists() and not dst.exists():
                        dst.write_bytes(src.read_bytes())
            summary_rows.append(add_summary(cd["label"], best, cd["lc_only"]))

            # envelope / A-step ISO (optional)
            if bool(args.export_envelope) or bool(args.export_Astep_iso):
                envelope_over_A(cd["builder"], A_scales, ReC_nms,
                            cd["A_bases"], cd["A_kinds"],
                            float(args.theta), float(args.phi), c1, c2, outdir, cd["tag"])
                if bool(args.export_Astep_iso):
                    export_Astep_iso_from_envelope(
                        tag=cd["tag"],
                        envelope_csv=outdir / f"A_envelope_{cd['tag']}.csv",
                        outdir=outdir,
                        stride=int(args.Astep_iso_stride),
                        builder_kind=cd["tag"],
                        pol_in=float(args.pol_in), pol_out=float(args.pol_out),
                        relA=float(args.relA), relLC=float(args.relLC),
                        theta_max=float(args.Astep_iso_theta_max),
                        dtheta=float(args.Astep_iso_dtheta),
                        dphi=float(args.Astep_iso_dphi),
                    )
    # --- ISO plots ---
    if not bool(args.skip_iso):

        # --- ISO plots ---
        # Always save LC-only ISO for comparison (both bases)
        save_iso(LC_only_abs,  "ISO-CR (LC only, absorption-basis)", outdir / "iso_LC_only_abs.png", c1, c2)
        save_iso(LC_only_tran, "ISO-CR (LC only, transmission-basis +90°)", outdir / "iso_LC_only_tran.png", c1, c2)

        for key in keys_to_run:
            cd = case_defs[key]
            best, _prog = results[key]
            title = f"ISO-CR ({cd['tag']} best; A_scale={best['A_scale']:.2f}, ReC={best['ReC_nm']:.0f}nm)"
            save_iso(best["stack"], title, outdir / f"iso_{cd['tag']}_best.png", c1, c2)
            legacy = {"case1":"iso_1_best.png","case2":"iso_2_best.png","case3":"iso_3_best.png"}.get(cd["tag"])
            if legacy is not None:
                save_iso(best["stack"], title, outdir / legacy, c1, c2)


    # --- Stokes traces for best stacks ---
    if not bool(args.skip_stokes):
        for key in keys_to_run:
            cd = case_defs[key]
            best, _prog = results[key]
            save_stokes_traces(cd["tag"], st_theta, st_phi, best["stack"], c1, c2, basis=args.stokes_basis, outdir=outdir)

    # --- Summary ---
    if not bool(args.skip_summary):
        df_sum = pd.DataFrame(summary_rows)
        df_sum.to_csv(outdir / "summary.csv", index=False)

    print(f"\nSaved all outputs to: {outdir.resolve()}")
    if args.track_progress:
        print("Progress logs saved: progress_case*.csv/.json")


if __name__ == "__main__":
    main()

