# -*- coding: utf-8 -*-
"""IPS_compensation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Og7g_qGVBpJDO0U15BFEGUVoAC4aPtI_
"""

!rm -r /content/out_iso_pairrot

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_realistic_iso_with_TAC_clip_rot_POLA_relA.py

Purpose:
  - Realistic IPS retarder-only stack (TAC repeat + optional symmetric C-plates + A/LC/A)
  - Add rotation controls:
      (1) POL + corresponding A pair rotation (input-side and/or output-side)
      (2) Additional rotation of L-A / U-A relative to their POL (misalignment inside the pair)
  - Keep the same overall workflow structure:
      2) linecut(theta=60)  ... per A_scale (and rotation case) -> 1 png
      3) polar iso-CR contours ... per (A_scale, C_case, rotation case) -> 1 png
  - Also prints CR@theta≈0 (mean/min/max across phi) for each case.

Notes:
  - This script is standalone (does NOT import ips_compensation2*.py).
  - Polarizers are ideal O-type and are represented by absorption axes c1/c2;
    pass states are o(k,c)=normalize(k×c).
  - If you set:
        POL_PAIR_ROT_IN = 0, POL_PAIR_ROT_OUT = 0,
        REL_ROT_LA = 0, REL_ROT_UA = 0
    you recover the baseline model.
  - If you set REL_ROT_* = 0 and rotate only one side's POL_PAIR_ROT_*, you recover
    the previous "POL+A pair rotation vs LC" behavior.

"""

from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#
out_root = Path("./out_dispersion_match_vs_mismatch3")
out_root.mkdir(parents=True, exist_ok=True)

# -----------------------------
# Parameters (edit here)
# -----------------------------
### Wavelength handling
# Use white evaluation by averaging Tleak over representative wavelengths (B/G/R).
# NOTE: CR is computed from averaged Tleak (physically meaningful), not averaged CR.
WL_NM = {"B": 450.0, "G": 546.0, "R": 610.0}
WL_KEYS = ("B","G","R")
WL_WEIGHTS = {"B": 1.0, "G": 1.0, "R": 1.0}  # edit if needed

# Optional simple dn dispersion scaling relative to G.
# Set USE_DN_DISPERSION = True to use dn as constant; wavelength dependence then comes only from 1/λ.
USE_DN_DISPERSION = True
DN_SCALE_MATCHED = {
    # "Matched" example: LC dn dispersion and A-plate dn dispersion are aligned.
    # Values are scale factors of dn relative to G=546nm.
    "LC": {"B": 1.10, "G": 1.00, "R": 0.90},
    "A":  {"B": 1.10, "G": 1.00, "R": 0.90},
    # Keep others flat in this demo to isolate LC vs A mismatch
    "C":  {"B": 1.00, "G": 1.00, "R": 1.00},
    "TAC":{"B": 1.00, "G": 1.00, "R": 1.00},
}
DN_SCALE_MISMATCHED = {
    # "Mismatched" example: LC dispersion stays the same, but A dispersion is steeper (not aligned with LC).
    "LC": {"B": 1.10, "G": 1.00, "R": 0.90},
    "A":  {"B": 1.20, "G": 1.00, "R": 0.80},
    "C":  {"B": 1.00, "G": 1.00, "R": 1.00},
    "TAC":{"B": 1.00, "G": 1.00, "R": 1.00},
}
# DN_SCALE is the active one used by _ne_no_for_wl()
DN_SCALE = dict(DN_SCALE_MATCHED)

def wl_m(key):
    return WL_NM[key] * 1e-9

NO_BASE = 1.50  # simplified constant base index for all layers
def ne_from_dn(no, dn): return no + dn

# LC per rule (example)
dn_LC = 0.100
d_LC  = 3.1e-6

# A-plates birefringence (example)
dn_lowerA = 0.00145
dn_upperA = 0.00142

# C-plate birefringence (example)
dn_C = 0.12049

# Re allocation baseline for A(each)
RE_LC_NM = 310.0
RE_A_EACH_BASE_NM = RE_LC_NM / 2.0  # [nm]

# --- sweeps ---
A_SCALES   = [1.0, 1.5, 2.0]
C_CASES_UM = [None, 0.5, 1.0, 1.5]

# TAC
DN_TAC_CASES = [-0.0020]  # fixed as requested
TAC_REPEATS  = [1, ]
TAC_UM_CASES = [40.0]      # you can add [60.0] etc

# Rotation cases
# LC director is misaligned from input POL axis by this small angle (deg)
LC_REL_TO_INPOL_DEG = 1.0

#   POL_PAIR_ROT_* : rotate POL absorption axis AND (baseline) A axis together (pair rotation)
#   REL_ROT_*      : additional rotation of A axis relative to its POL (misalignment inside the pair)
POL_PAIR_ROT_IN_DEGS  = [0.5]   # input-side POL+A pair rotation
POL_PAIR_ROT_OUT_DEGS = [0.0]             # output-side pair rotation (set like [0,2.5,5] if needed)

REL_ROT_LA_DEGS = [0.5]   # small A-vs-POL misalignment to make A participate (deg)
REL_ROT_UA_DEGS = [0.]   # apply same small misalignment on analyzer side (deg)

# Grid / plots
DO_PLOTS = True  # set True if you need png outputs

THETA_LINECUT = 60.0
THETA_MAX     = 60.0
DTHETA        = 5.0
DPHI          = 5.0

CR0_TARGET   = 50000.0
CR_CROP_MAX  = 50000.0   # plot crop: CR > this => clipped
CR_LEVELS    = [100, 200, 500, 1000, 5000, 10000,20000]


# -----------------------------
# Math helpers
# -----------------------------
def normalize(v, eps=1e-15):
    v = np.array(v, dtype=float)
    n = np.linalg.norm(v)
    return v / max(n, eps)

def k_hat(theta_deg, phi_deg):
    th = np.deg2rad(theta_deg)
    ph = np.deg2rad(phi_deg)
    return np.array([np.sin(th)*np.cos(ph), np.sin(th)*np.sin(ph), np.cos(th)], dtype=float)

def o_axis_Otype(k, c):
    # O-type polarizer: ordinary polarization is perpendicular to (k,c) plane
    return normalize(np.cross(k, c))

def axis_azimuth_deg(axis_vec):
    a = np.array(axis_vec, dtype=float).copy()
    a[2] = 0.0
    if np.linalg.norm(a) < 1e-12:
        return 0.0
    return float(np.rad2deg(np.arctan2(a[1], a[0])))

def rotz_deg(vec3, deg):
    """In-plane rotation about +z by deg."""
    th = np.deg2rad(float(deg))
    c, s = np.cos(th), np.sin(th)
    x, y, z = float(vec3[0]), float(vec3[1]), float(vec3[2])
    return np.array([c*x - s*y, s*x + c*y, z], dtype=float)

def axis_from_azimuth_deg(deg):
    a = np.deg2rad(float(deg))
    return np.array([float(np.cos(a)), float(np.sin(a)), 0.0], dtype=float)


# -----------------------------
# Eq.(3a)/(3b) and retarder operator
# -----------------------------
def eq3a_Gamma_A(theta_deg, phi_deg_rel, lam, d, no, ne):
    th = np.deg2rad(theta_deg)
    ph = np.deg2rad(phi_deg_rel)
    s2 = np.sin(th)**2
    sin2 = np.sin(ph)**2
    cos2 = np.cos(ph)**2
    term_e = 1.0 - (s2*sin2)/(ne**2) - (s2*cos2)/(no**2)
    term_o = 1.0 - (s2)/(no**2)
    term_e = np.maximum(term_e, 0.0)
    term_o = np.maximum(term_o, 0.0)
    return (2*np.pi/lam) * d * (ne*np.sqrt(term_e) - no*np.sqrt(term_o))

def eq3b_Gamma_C(theta_deg, lam, d, no, ne):
    th = np.deg2rad(theta_deg)
    s2 = np.sin(th)**2
    c2 = np.cos(th)**2
    inside = (no**2 * ne**2) / (no**2 * s2 + ne**2 * c2)
    inside = np.maximum(inside, 1e-18)
    return (2*np.pi/lam) * (d/np.maximum(np.cos(th), 1e-12)) * (np.sqrt(inside) - no)

def retarder_matrix(k, axis_vec, Gamma):
    """
    3D-field retarder:
      - u: projection of axis onto plane ⟂k
      - v: k×u
      - apply phase ±Gamma/2 on (u,v)
    """
    k = normalize(k)
    axis_vec = normalize(axis_vec)

    a_perp = axis_vec - np.dot(axis_vec, k)*k
    if np.linalg.norm(a_perp) < 1e-12:
        tmp = np.array([1.0, 0.0, 0.0])
        if abs(np.dot(tmp, k)) > 0.9:
            tmp = np.array([0.0, 1.0, 0.0])
        a_perp = tmp - np.dot(tmp, k)*k

    u = normalize(a_perp)
    v = normalize(np.cross(k, u))

    uu = np.outer(u, u)
    vv = np.outer(v, v)
    kk = np.outer(k, k)

    ph_plus  = np.exp(1j*Gamma/2)
    ph_minus = np.exp(-1j*Gamma/2)

    return ph_plus*uu + ph_minus*vv + kk


# -----------------------------
# Stack builder (realistic, with rotations)
# -----------------------------
def build_stack_realistic(
    dC_um,
    A_scale,
    tac_repeat=1,
    tac_um=40.0,
    dn_tac=-0.0020,
    # rotations
    pol_pair_rot_in_deg=0.0,
    pol_pair_rot_out_deg=0.0,
    rel_rot_LA_deg=0.0,
    rel_rot_UA_deg=0.0,
    lc_rel_to_inpol_deg=0.0,
):
    """
    Retarder-only stack for IPS CR study (no dispersion):

      TAC(-C) x N / (L-C) / L-A(rot) / LC(fixed 0deg) / U-A(rot) / (U-C) / TAC(-C) x N

    Polarizers are NOT in the stack; they are applied in Tleak_stack_scalar via c1/c2.

    Rotations:
      - Input POL absorption axis c1 is rotated by pol_pair_rot_in_deg.
      - Analyzer absorption axis c2 is rotated by pol_pair_rot_out_deg.
      - Lower A axis is rotated by (pol_pair_rot_in_deg + rel_rot_LA_deg) from its baseline (0deg).
      - Upper A axis is rotated by (pol_pair_rot_out_deg + rel_rot_UA_deg) from its baseline (90deg).

    If rel_rot_* = 0, each side's POL and its A move together (pair rotation).
    """
    # --- TAC ---
    tac_layer = {"type":"C", "axis":[0,0,1], "d":float(tac_um)*1e-6,
                 "no":NO_BASE, "ne":ne_from_dn(NO_BASE, float(dn_tac))}

    # --- A thickness from Re_each ---
    Re_each_m = (RE_A_EACH_BASE_NM * 1e-9) * float(A_scale)
    d_lower = Re_each_m / float(dn_lowerA)
    d_upper = Re_each_m / float(dn_upperA)

    # --- axes with rotations ---
    base_LA = axis_from_azimuth_deg(0.0)
    base_UA = axis_from_azimuth_deg(90.0)

    axis_LA = rotz_deg(base_LA, float(pol_pair_rot_in_deg) + float(rel_rot_LA_deg))
    axis_UA = rotz_deg(base_UA, float(pol_pair_rot_out_deg) + float(rel_rot_UA_deg))

    # LC director: follow input-side reference (pair rotation) with a small relative misalignment
    # lc_rel_to_inpol_deg = +1 deg means LC director is rotated +1 deg from the input POL axis (in the same sense as rotz)
    axis_LC = rotz_deg(axis_from_azimuth_deg(0.0), float(pol_pair_rot_in_deg) + float(lc_rel_to_inpol_deg))

    stack = []

    # TAC in
    for _ in range(int(tac_repeat)):
        stack.append(dict(tac_layer))

    # L-C (optional)
    if dC_um is not None and float(dC_um) > 0:
        stack.append({"type":"C", "axis":[0,0,1], "d":float(dC_um)*1e-6,
                      "no":NO_BASE, "ne":ne_from_dn(NO_BASE, float(dn_C))})

    # L-A / LC / U-A
    stack += [
        {"type":"A", "axis":axis_LA.tolist(), "d":float(d_lower), "no":NO_BASE, "ne":ne_from_dn(NO_BASE, float(dn_lowerA))},
        {"type":"LC","axis":axis_LC.tolist(), "d":float(d_LC),    "no":NO_BASE, "ne":ne_from_dn(NO_BASE, float(dn_LC))},
        {"type":"A", "axis":axis_UA.tolist(), "d":float(d_upper), "no":NO_BASE, "ne":ne_from_dn(NO_BASE, float(dn_upperA))},
    ]

    # U-C (optional)
    if dC_um is not None and float(dC_um) > 0:
        stack.append({"type":"C", "axis":[0,0,1], "d":float(dC_um)*1e-6,
                      "no":NO_BASE, "ne":ne_from_dn(NO_BASE, float(dn_C))})

    # TAC out
    for _ in range(int(tac_repeat)):
        stack.append(dict(tac_layer))

    return stack


def pol_axes(pol_pair_rot_in_deg=0.0, pol_pair_rot_out_deg=0.0):
    """
    Return (c1, c2) absorption axes for input POL and analyzer.
    Baseline:
      c1 = x-hat, c2 = y-hat (crossed at normal incidence in this O-type convention).
    Then apply in-plane rotations separately.
    """
    c1 = rotz_deg(np.array([1.0, 0.0, 0.0]), float(pol_pair_rot_in_deg))
    c2 = rotz_deg(np.array([0.0, 1.0, 0.0]), float(pol_pair_rot_out_deg))
    return c1, c2


# -----------------------------
# Leakage + CR
# -----------------------------
def CR_from_Tleak(Tleak):
    return 1.0 / (Tleak + 1.0/CR0_TARGET)

def _ne_no_for_wl(el, wl_key):
    """
    Return (no, ne) at a given wavelength key.
    In this script, el["no"], el["ne"] are treated as the Green (G) values.
    If USE_DN_DISPERSION is False, we keep dn constant and only 1/lambda changes Gamma.
    """
    no = float(el["no"])
    neG = float(el["ne"])
    dnG = neG - no
    if not USE_DN_DISPERSION:
        return no, no + dnG

    t = el["type"]
    scale = DN_SCALE.get(t, {"B":1.0,"G":1.0,"R":1.0}).get(wl_key, 1.0)
    return no, no + dnG * float(scale)


def Tleak_stack_scalar(theta_deg, phi_deg, stack,
                       c1=np.array([1.,0.,0.]), c2=np.array([0.,1.,0.])):
    """
    White evaluation:
      Tleak(theta,phi) = weighted average over WL_KEYS of Tleak(lambda).
    """
    k = k_hat(theta_deg, phi_deg)
    o1 = o_axis_Otype(k, c1)
    o2 = o_axis_Otype(k, c2)

    # incident field after input polarizer
    E0 = o1.astype(complex)

    Tsum = 0.0
    wsum = 0.0

    for wl_key in WL_KEYS:
        lam = wl_m(wl_key)
        w = float(WL_WEIGHTS.get(wl_key, 1.0))

        E = E0.copy()

        for el in stack:
            no, ne = _ne_no_for_wl(el, wl_key)

            if el["type"] in ("A","LC"):
                alpha = axis_azimuth_deg(el["axis"])
                phi_rel = phi_deg - alpha
                Gamma = float(eq3a_Gamma_A(theta_deg, phi_rel, lam, el["d"], no, ne))
            elif el["type"] == "C":
                Gamma = float(eq3b_Gamma_C(theta_deg, lam, el["d"], no, ne))
            else:
                raise ValueError("Unknown element type")

            M = retarder_matrix(k, np.array(el["axis"], dtype=float), Gamma)
            E = M @ E
            E = E - np.dot(E, k)*k  # enforce transverse field

        amp = np.dot(o2, E)
        T = 0.5 * (abs(amp)**2)  # Fresnel term omitted

        Tsum += w * float(np.real(T))
        wsum += w

    return Tsum / max(wsum, 1e-30)


# -----------------------------
# CR grids / plotting
# -----------------------------
def compute_CR_grid(stack, c1, c2, theta_max=60.0, dtheta=5.0, dphi=5.0):
    thetas = np.arange(0.0, float(theta_max) + 1e-12, float(dtheta))
    phis   = np.arange(0.0, 360.0 + 1e-12, float(dphi))

    CR = np.zeros((len(thetas), len(phis)), dtype=float)
    for i, th in enumerate(thetas):
        for j, ph in enumerate(phis):
            T = Tleak_stack_scalar(float(th), float(ph), stack, c1=c1, c2=c2)
            CR[i, j] = CR_from_Tleak(T)
    return thetas, phis, CR

def compute_CR0_stats(thetas, CR):
    idx0 = int(np.argmin(np.abs(thetas)))
    cr0_row = CR[idx0, :]
    return float(thetas[idx0]), float(np.mean(cr0_row)), float(np.min(cr0_row)), float(np.max(cr0_row))

def plot_linecut_theta60(d_C_list_um, A_scale, theta_cut=60.0,
                         tac_repeat=1, tac_um=40.0, dn_tac=-0.0020,
                         pol_pair_rot_in_deg=0.0, pol_pair_rot_out_deg=0.0,
                         rel_rot_LA_deg=0.0, rel_rot_UA_deg=0.0,
                         out_png="linecut_theta60.png"):
    phis = np.arange(0.0, 360.0 + 1e-12, 1.0)
    fig = plt.figure(figsize=(6.8,3.6), dpi=200)
    ax = fig.add_subplot(111)

    c1, c2 = pol_axes(pol_pair_rot_in_deg, pol_pair_rot_out_deg)

    for d_um in d_C_list_um:
        labelC = "No_C" if d_um is None else f"C_d{float(d_um):.1f}um"
        stack = build_stack_realistic(
            d_um, A_scale,
            tac_repeat=tac_repeat, tac_um=tac_um, dn_tac=dn_tac,
            pol_pair_rot_in_deg=pol_pair_rot_in_deg,
            pol_pair_rot_out_deg=pol_pair_rot_out_deg,
            rel_rot_LA_deg=rel_rot_LA_deg,
            rel_rot_UA_deg=rel_rot_UA_deg,
        )

        CR_line = np.array([CR_from_Tleak(Tleak_stack_scalar(theta_cut, float(ph), stack, c1=c1, c2=c2))
                            for ph in phis])
        ax.plot(phis, CR_line, label=f"{labelC}")

    ax.set_yscale("log")
    ax.set_xlim(0, 360)
    ax.set_ylim(1, max(CR0_TARGET, 1e3))
    ax.set_xlabel("phi [deg]")
    ax.set_ylabel("CR")
    ax.set_title(
        f"Linecut at theta={theta_cut:.0f}°  "
        f"A_scale={A_scale:.2f}, TACx{int(tac_repeat)}@{tac_um:g}um, "
        f"POLpair(in={pol_pair_rot_in_deg:g},out={pol_pair_rot_out_deg:g})deg, "
        f"relA(L={rel_rot_LA_deg:g},U={rel_rot_UA_deg:g})deg"
    )
    ax.grid(True, which="both", ls=":")
    ax.legend(fontsize=8, loc="best")
    fig.tight_layout()
    fig.savefig(out_png)
    plt.close(fig)

def plot_isocontrast_polar(thetas, phis, CR, title, out_path, legend_every=2):
    """
    Plot iso-CR polar contour (theta radial, phi azimuth).
    CR is clipped at CR_CROP_MAX for plotting clarity.
    """
    CR_plot = np.minimum(CR, float(CR_CROP_MAX))

    PHI, TH = np.meshgrid(np.deg2rad(phis), thetas)
    fig = plt.figure(figsize=(5.2,4.6), dpi=220)
    ax = fig.add_subplot(111, projection="polar")
    cs = ax.contour(PHI, TH, CR_plot, levels=CR_LEVELS)

    # Legend entries (avoid too crowded)
    handles = []
    labels = []
    for k, lev in enumerate(cs.levels):
        if legend_every is None or legend_every <= 1 or (k % int(legend_every) == 0):
            handles.append(plt.Line2D([0],[0], color="k", lw=1))
            labels.append(f"{lev:g}")
    if handles:
        ax.legend(handles, labels, title="CR levels", fontsize=8, loc="upper right", bbox_to_anchor=(1.25, 1.10))

    ax.set_thetagrids(np.arange(0, 360, 45))
    ax.set_rmax(float(np.max(thetas)))
    ax.set_rlabel_position(135)
    ax.grid(True, ls=":")
    ax.set_title(title, fontsize=9)
    fig.tight_layout()
    fig.savefig(out_path)
    plt.close(fig)


# -----------------------------
# Main sweep routine
# -----------------------------
def main(case_name="matched", dn_scale=None, out_root="./out_iso_rot"):
    out_dir = Path(out_root) / str(case_name)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Set dispersion map for this run
    if dn_scale is not None:
        global DN_SCALE
        DN_SCALE = dict(dn_scale)

    rows = []

    for dn_tac in DN_TAC_CASES:
        for tac_repeat in TAC_REPEATS:
            for tac_um in TAC_UM_CASES:

                # 2) linecut(theta=60): one png per (A_scale, rotation case)
                for A_scale in A_SCALES:
                    for pol_in in POL_PAIR_ROT_IN_DEGS:
                        for pol_out in POL_PAIR_ROT_OUT_DEGS:
                            for rel_L in REL_ROT_LA_DEGS:
                                for rel_U in REL_ROT_UA_DEGS:
                                    out_png = out_dir / (
                                        f"linecut_theta{THETA_LINECUT:.0f}_"
                                        f"Ax{A_scale:.2f}_"
                                        f"POLin{pol_in:+.1f}_POLout{pol_out:+.1f}_"
                                        f"relL{rel_L:+.1f}_relU{rel_U:+.1f}_"
                                        f"TACx{int(tac_repeat)}_{tac_um:g}um.png"
                                    )
                                    plot_linecut_theta60(
                                        C_CASES_UM, A_scale,
                                        theta_cut=float(THETA_LINECUT),
                                        tac_repeat=int(tac_repeat), tac_um=float(tac_um), dn_tac=float(dn_tac),
                                        pol_pair_rot_in_deg=float(pol_in),
                                        pol_pair_rot_out_deg=float(pol_out),
                                        rel_rot_LA_deg=float(rel_L),
                                        rel_rot_UA_deg=float(rel_U),
                                        out_png=str(out_png),
                                    )

                # 3) polar iso-CR contours: save per (A_scale, C_case, rotation case)
                for A_scale in A_SCALES:
                    for dC_um in C_CASES_UM:
                        labelC = "No_C" if dC_um is None else f"C_d{float(dC_um):.1f}um"

                        for pol_in in POL_PAIR_ROT_IN_DEGS:
                            for pol_out in POL_PAIR_ROT_OUT_DEGS:
                                for rel_L in REL_ROT_LA_DEGS:
                                    for rel_U in REL_ROT_UA_DEGS:

                                        stack = build_stack_realistic(
                                            dC_um, A_scale,
                                            tac_repeat=int(tac_repeat), tac_um=float(tac_um), dn_tac=float(dn_tac),
                                            pol_pair_rot_in_deg=float(pol_in),
                                            pol_pair_rot_out_deg=float(pol_out),
                                            rel_rot_LA_deg=float(rel_L),
                                            rel_rot_UA_deg=float(rel_U),
                                        )
                                        c1, c2 = pol_axes(pol_in, pol_out)

                                        thetas, phis, CR = compute_CR_grid(
                                            stack, c1, c2,
                                            theta_max=float(THETA_MAX),
                                            dtheta=float(DTHETA),
                                            dphi=float(DPHI)
                                        )

                                        th0, cr0_mean, cr0_min, cr0_max = compute_CR0_stats(thetas, CR)
                                        min_cr = float(np.min(CR[thetas >= 10.0, :])) if np.any(thetas >= 10.0) else float(np.min(CR))

                                        title = (
                                            f"Ax{A_scale:.2f}, {labelC}, TACx{int(tac_repeat)}@{tac_um:g}um, dnTAC={dn_tac:+.4f}\n"
                                            f"POLpair(in={pol_in:g},out={pol_out:g})deg, relA(L={rel_L:g},U={rel_U:g})deg, "
                                            f"CR0≈{cr0_mean:.0f} (min {cr0_min:.0f})"
                                        )

                                        out_png = out_dir / (
                                            f"CR_polar_"
                                            f"Ax{A_scale:.2f}_{labelC}_"
                                            f"POLin{pol_in:+.1f}_POLout{pol_out:+.1f}_"
                                            f"relL{rel_L:+.1f}_relU{rel_U:+.1f}_"
                                            f"TACx{int(tac_repeat)}_{tac_um:g}um.png"
                                        )
                                        if DO_PLOTS:
                                            plot_isocontrast_polar(thetas, phis, CR, title=title, out_path=str(out_png))

                                        print(
                                            f"[case] Ax{A_scale:.2f}, {labelC}, TACx{int(tac_repeat)}@{tac_um:g}um, dnTAC={dn_tac:+.4f} | "
                                            f"POL(in={pol_in:g},out={pol_out:g}) relA(L={rel_L:g},U={rel_U:g}) | "
                                            f"CR0(mean/min/max)={cr0_mean:.1f}/{cr0_min:.1f}/{cr0_max:.1f} | "
                                            f"minCR(theta>=10)={min_cr:.1f}"
                                        )

                                        rows.append({
                                            "A_scale": float(A_scale),
                                            "dC_um": 0.0 if dC_um is None else float(dC_um),
                                            "tac_repeat": int(tac_repeat),
                                            "tac_um": float(tac_um),
                                            "dn_tac": float(dn_tac),
                                            "POLpair_in_deg": float(pol_in),
                                            "POLpair_out_deg": float(pol_out),
                                            "rel_LA_deg": float(rel_L),
                                            "rel_UA_deg": float(rel_U),
                                            "CR0_theta_deg": float(th0),
                                            "CR0_mean": float(cr0_mean),
                                            "CR0_min": float(cr0_min),
                                            "CR0_max": float(cr0_max),
                                            "minCR_theta_ge_10": float(min_cr),
                                        })

    df = pd.DataFrame(rows)
    out_csv = out_dir / "summary_CR0_and_minCR.csv"
    df.to_csv(out_csv, index=False)
    print(f"\nSaved summary: {out_csv.resolve()}")



def demo_CR0_dispersion_effect():
    """Demonstrate that LC-vs-A dispersion mismatch can reduce CR0_white.

    Setup (kept consistent with your request):
      - POL and A are rotated together (pair rotation)
      - small A-vs-POL misalignment inside pair: REL_ROT_* = 0.5 deg
      - LC director is misaligned from input POL by +1.0 deg
      - Evaluate CR0 at theta=0, averaged over phi (should be constant at theta=0 but kept for safety)
      - A_scale is chosen by optimizing CR0 for GREEN only (WL_KEYS=("G",)) in the MATCHED case.
    """
    global WL_KEYS, DN_SCALE

    # Use fixed geometric/rotation settings (same as parameter block)
    pol_in = float(POL_PAIR_ROT_IN_DEGS[0])
    pol_out = float(POL_PAIR_ROT_OUT_DEGS[0])
    rel_LA = float(REL_ROT_LA_DEGS[0])
    rel_UA = float(REL_ROT_UA_DEGS[0])
    lc_rel = float(LC_REL_TO_INPOL_DEG)

    # Sweep A_scale for green-only optimization
    Agrid = np.linspace(0.2, 3.0, 57)

    def CR0_mean_for_A(A_scale):
        stack = build_stack_realistic(
            dC_um=None, A_scale=A_scale,
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=pol_in, pol_pair_rot_out_deg=pol_out,
            rel_rot_LA_deg=rel_LA, rel_rot_UA_deg=rel_UA,
            lc_rel_to_inpol_deg=lc_rel,
        )
        c1, c2 = pol_axes(pol_in, pol_out)
        phis = np.arange(0, 361, 10)
        CRs = []
        for ph in phis:
            T = Tleak_stack_scalar(0.0, float(ph), stack, c1=c1, c2=c2)
            CRs.append(CR_from_Tleak(float(T)))
        return float(np.mean(CRs))

    # 1) Optimize at GREEN only for matched case
    old_keys = WL_KEYS
    WL_KEYS = ("G",)
    DN_SCALE = dict(DN_SCALE_MATCHED)
    bestA = None
    bestCRg = -1.0
    for A_scale in Agrid:
        crg = CR0_mean_for_A(float(A_scale))
        if crg > bestCRg:
            bestCRg = crg
            bestA = float(A_scale)

    # 2) Evaluate WHITE CR0 at that thickness for matched vs mismatched
    WL_KEYS = ("B","G","R")

    DN_SCALE = dict(DN_SCALE_MATCHED)
    CRw_match = CR0_mean_for_A(bestA)

    DN_SCALE = dict(DN_SCALE_MISMATCHED)
    CRw_mismatch = CR0_mean_for_A(bestA)

    WL_KEYS = old_keys

    print("\n=== Dispersion mismatch demo (theta=0, WHITE=avg Tleak over B/G/R) ===")
    print(f"Fixed rotations: pol_in={pol_in}deg, pol_out={pol_out}deg, rel_LA=rel_UA=0.5deg, LC_rel_to_inPOL={lc_rel}deg")
    print(f"Best A_scale at GREEN (matched case): A_scale = {bestA:.2f} (CR0_G ≈ {bestCRg:.1f})")
    print(f"CR0_WHITE (matched dispersion)    : {CRw_match:.1f}")
    print(f"CR0_WHITE (mismatched dispersion) : {CRw_mismatch:.1f}")
    print(f"Ratio mismatch/match              : {CRw_mismatch/CRw_match:.3f}")


# ============================================================
# Compare matched vs mismatched with plots (old-structure style)
# ============================================================
def compare_matched_mismatched_with_plots():
    """
    1) Find best A_scale at GREEN for MATCHED dispersion (theta=0).
    2) Evaluate CR0_WHITE for matched vs mismatched at that same best A_scale.
    3) Generate:
       - linecut(theta=THETA_LINECUT)  : saved for each dispersion case
       - polar isocontrast contours    : saved for each dispersion case
    """
    global WL_KEYS, DN_SCALE

    # Fixed rotation settings (your request)
    pol_in  = float(POL_PAIR_ROT_IN_DEGS[0])
    pol_out = float(POL_PAIR_ROT_OUT_DEGS[0])
    rel_LA  = float(REL_ROT_LA_DEGS[0])
    rel_UA  = float(REL_ROT_UA_DEGS[0])
    lc_rel  = float(LC_REL_TO_INPOL_DEG)

    # -------- 1) Optimize A at GREEN for matched --------
    old_keys = WL_KEYS
    WL_KEYS = ("G",)
    DN_SCALE = dict(DN_SCALE_MATCHED)

    Agrid = np.linspace(0.2, 3.0, 57)

    def CR0_mean_for_A(A_scale, dn_scale):
        DN_SCALE_local = dn_scale
        # Use current WL_KEYS (caller sets)
        # Build stack at dC=None for CR0
        stack = build_stack_realistic(
            dC_um=None, A_scale=float(A_scale),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=pol_in, pol_pair_rot_out_deg=pol_out,
            rel_rot_LA_deg=rel_LA, rel_rot_UA_deg=rel_UA,
            lc_rel_to_inpol_deg=lc_rel,
        )
        c1, c2 = pol_axes(pol_in, pol_out)
        phis = np.arange(0.0, 360.0 + 1e-12, 10.0)
        CRs = []
        # Temporarily swap global DN_SCALE for reuse of Tleak_stack_scalar path
        global DN_SCALE
        old = DN_SCALE
        DN_SCALE = dict(DN_SCALE_local)
        try:
            for ph in phis:
                T = Tleak_stack_scalar(0.0, float(ph), stack, c1=c1, c2=c2)
                CRs.append(CR_from_Tleak(float(T)))
        finally:
            DN_SCALE = old
        return float(np.mean(CRs))

    bestA, bestCRg = None, -1.0
    for A_scale in Agrid:
        CRg = CR0_mean_for_A(A_scale, DN_SCALE_MATCHED)
        if CRg > bestCRg:
            bestCRg = CRg
            bestA = float(A_scale)

    # -------- 2) Evaluate WHITE at bestA --------
    WL_KEYS = ("B","G","R")
    CRw_match    = CR0_mean_for_A(bestA, DN_SCALE_MATCHED)
    CRw_mismatch = CR0_mean_for_A(bestA, DN_SCALE_MISMATCHED)

    print("\n=== Dispersion mismatch demo (theta=0, WHITE=avg Tleak over B/G/R) ===")
    print(f"Fixed rotations: pol_in={pol_in}deg, pol_out={pol_out}deg, rel_LA=rel_UA={rel_LA}deg, LC_rel_to_inPOL={lc_rel}deg")
    print(f"Best A_scale at GREEN (matched case): A_scale = {bestA:.2f} (CR0_G ≈ {bestCRg:.1f})")
    print(f"CR0_WHITE (matched dispersion)    : {CRw_match:.1f}")
    print(f"CR0_WHITE (mismatched dispersion) : {CRw_mismatch:.1f}")
    print(f"Ratio mismatch/match              : {CRw_mismatch/CRw_match:.3f}")

    # -------- 3) Plots in old structure --------

    for case_name, dn_scale in [("matched", DN_SCALE_MATCHED), ("mismatched", DN_SCALE_MISMATCHED)]:
        DN_SCALE = dict(dn_scale)
        out_dir = out_root / case_name
        out_dir.mkdir(parents=True, exist_ok=True)

        # linecut
        out_png = out_dir / f"linecut_theta{THETA_LINECUT:.0f}_bestA.png"
        plot_linecut_theta60(
            d_C_list_um=[None], A_scale=bestA, theta_cut=float(THETA_LINECUT),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=pol_in, pol_pair_rot_out_deg=pol_out,
            rel_rot_LA_deg=rel_LA, rel_rot_UA_deg=rel_UA,
            out_png=str(out_png),
            lc_rel_to_inpol_deg=lc_rel,   # <-- extended signature below
        )

        # polar iso-CR
        labelC = "No_C"
        title = f"{case_name} | bestA={bestA:.2f} | pol_in={pol_in} pol_out={pol_out} rel={rel_LA} LCrel={lc_rel} | {labelC}"
        stack = build_stack_realistic(
            dC_um=None, A_scale=bestA,
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=pol_in, pol_pair_rot_out_deg=pol_out,
            rel_rot_LA_deg=rel_LA, rel_rot_UA_deg=rel_UA,
            lc_rel_to_inpol_deg=lc_rel,
        )
        c1, c2 = pol_axes(pol_in, pol_out)
        thetas, phis, CR = compute_CR_grid(stack, c1, c2, theta_max=float(THETA_MAX), dtheta=float(DTHETA), dphi=float(DPHI))
        out_png = out_dir / f"CR_polar_bestA_{labelC}.png"
        plot_isocontrast_polar(thetas, phis, CR, title=title, out_path=str(out_png))

    WL_KEYS = old_keys


# ---- extend plot_linecut_theta60 to propagate LC axis offset ----
# We keep backward compatibility: if lc_rel_to_inpol_deg is not given, it defaults to 0.0.
_old_plot_linecut_theta60 = plot_linecut_theta60
def plot_linecut_theta60(d_C_list_um, A_scale, theta_cut=60.0,
                         tac_repeat=1, tac_um=40.0, dn_tac=-0.0020,
                         pol_pair_rot_in_deg=0.0, pol_pair_rot_out_deg=0.0,
                         rel_rot_LA_deg=0.0, rel_rot_UA_deg=0.0,
                         out_png="linecut_theta60.png",
                         lc_rel_to_inpol_deg=0.0):
    phis = np.arange(0.0, 360.0 + 1e-12, 1.0)
    fig = plt.figure(figsize=(6.8,3.6), dpi=200)
    ax = fig.add_subplot(111)

    c1, c2 = pol_axes(pol_pair_rot_in_deg, pol_pair_rot_out_deg)

    for d_um in d_C_list_um:
        labelC = "No_C" if d_um is None else f"C_d{float(d_um):.1f}um"
        stack = build_stack_realistic(
            d_um, A_scale,
            tac_repeat=tac_repeat, tac_um=tac_um, dn_tac=dn_tac,
            pol_pair_rot_in_deg=pol_pair_rot_in_deg,
            pol_pair_rot_out_deg=pol_pair_rot_out_deg,
            rel_rot_LA_deg=rel_rot_LA_deg,
            rel_rot_UA_deg=rel_rot_UA_deg,
            lc_rel_to_inpol_deg=lc_rel_to_inpol_deg,  # <-- important
        )

        CR_line = np.array([CR_from_Tleak(Tleak_stack_scalar(theta_cut, float(ph), stack, c1=c1, c2=c2))
                            for ph in phis], dtype=float)

        ax.plot(phis, CR_line, label=labelC)

    ax.set_xlabel("phi [deg]")
    ax.set_ylabel(f"CR at theta={theta_cut:g} deg")
    ax.set_yscale("log")
    ax.set_ylim(10, CR_CROP_MAX)
    ax.grid(True, which="both", alpha=0.3)
    ax.legend(loc="best", fontsize=8)
    fig.tight_layout()
    fig.savefig(out_png)
    plt.close(fig)


if __name__ == "__main__":
    compare_matched_mismatched_with_plots()



# ============================================================
# Added: Verification ISO plot routine (same conditions as demo)
# ============================================================
def run_verification_iso_plots(out_dir="verification_iso_plots",
                               dC_list=(None, 1.0),
                               pol_in=0.0, pol_out=0.0,
                               relA=0.5, lc_rel=1.0,
                               Agrid=None,
                               dphi_opt=10.0):
    """
    Generate ISO (polar isocontrast) plots for the same verification conditions used in the
    dispersion mismatch demo, using the same best-A search (GREEN @ theta=0) and then
    computing WHITE iso-CR over the full theta/phi grid.

    Default verification conditions:
      - pol_in/out = 0/0 deg
      - relA(L=U)  = 0.5 deg
      - lc_rel_to_inpol_deg = 1.0 deg
      - bestA search grid   = linspace(0.2, 3.0, 57)
      - C-plate thickness   = [None, 1.0] um
    """
    import numpy as np
    from pathlib import Path

    if Agrid is None:
        Agrid = np.linspace(0.2, 3.0, 57)

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    def cr0_theta0_phiavg_manual(stack, c1, c2, dphi_deg, wl_keys, dn_scale_map):
        global WL_KEYS, DN_SCALE
        WL_KEYS = tuple(wl_keys)
        DN_SCALE = dict(dn_scale_map)
        phis = np.arange(0.0, 360.0 + 1e-12, float(dphi_deg))
        CRs = []
        for phi in phis:
            T = Tleak_stack_scalar(0.0, float(phi), stack, c1, c2)
            CRs.append(CR_from_Tleak(T))
        return float(np.mean(CRs))

    def find_bestA(dC_um):
        c1, c2 = pol_axes(pol_in, pol_out)
        bestA, bestCRG = None, -1.0
        for A in Agrid:
            stack = build_stack_realistic(
                dC_um=dC_um, A_scale=float(A),
                tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
                pol_pair_rot_in_deg=pol_in, pol_pair_rot_out_deg=pol_out,
                rel_rot_LA_deg=relA, rel_rot_UA_deg=relA,
                lc_rel_to_inpol_deg=lc_rel,
            )
            crg = cr0_theta0_phiavg_manual(stack, c1, c2, dphi_opt, ("G",), DN_SCALE_MATCHED)
            if crg > bestCRG:
                bestCRG, bestA = crg, float(A)
        return bestA, bestCRG

    for dC_um in dC_list:
        labelC = "No_C" if dC_um is None else f"C_d{float(dC_um):.1f}um"
        bestA, bestCRG = find_bestA(dC_um)
        c1, c2 = pol_axes(pol_in, pol_out)

        for case_name, dn_map in [("matched", DN_SCALE_MATCHED), ("mismatched", DN_SCALE_MISMATCHED)]:
            global DN_SCALE, WL_KEYS
            DN_SCALE = dict(dn_map)
            WL_KEYS = ("B", "G", "R")  # WHITE

            stack = build_stack_realistic(
                dC_um=dC_um, A_scale=float(bestA),
                tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
                pol_pair_rot_in_deg=pol_in, pol_pair_rot_out_deg=pol_out,
                rel_rot_LA_deg=relA, rel_rot_UA_deg=relA,
                lc_rel_to_inpol_deg=lc_rel,
            )
            thetas, phis, CR = compute_CR_grid(stack, c1, c2, theta_max=THETA_MAX, dtheta=DTHETA, dphi=DPHI)
            _, cr0_mean, _, _ = compute_CR0_stats(thetas, CR)

            title = (f"{case_name} | WHITE | {labelC}\n"
                     f"bestA(from G@theta0)={bestA:.2f} (CR0_G≈{bestCRG:.1f})\n"
                     f"pol_in/out={pol_in:g}/{pol_out:g}, relA={relA:g}, lc_rel={lc_rel:g}\n"
                     f"CR0_WHITE(mean)={cr0_mean:.1f}")

            out_png = out_dir / f"ISO_verify_{case_name}_WHITE_{labelC}_bestA{bestA:.2f}.png"
            plot_isocontrast_polar(thetas, phis, CR, title, out_png)

    print(f"[run_verification_iso_plots] Done. Output dir: {out_dir.resolve()}")



# ============================================================
# Added: A-scale sweep to verify CR>threshold region expands/shrinks
#        + ISO contour (no fill) for readability
# ============================================================
def _iso_contour_lines_polar(thetas_deg, phis_deg, CR, title, out_path,
                             levels=(100, 250, 500, 750, 1000, 1500, 2000, 3000, 5000, 10000, 20000, 50000),
                             cr_cap=None):
    """
    Polar ISO plot with contour *lines* (no fill).
    thetas_deg: 1D degrees (radius)
    phis_deg  : 1D degrees (angle)
    CR        : 2D [theta, phi]
    """
    import numpy as np
    import matplotlib.pyplot as plt

    TH, PH = np.meshgrid(np.deg2rad(thetas_deg), np.deg2rad(phis_deg), indexing="ij")
    Z = np.array(CR, dtype=float)
    if cr_cap is not None:
        Z = np.minimum(Z, float(cr_cap))

    # Trim levels to cap if needed
    lv = list(levels)
    if cr_cap is not None:
        lv = sorted(set([x for x in lv if x <= cr_cap] + [float(cr_cap)]))

    fig = plt.figure(figsize=(6.2, 6.2))
    ax = fig.add_subplot(111, projection="polar")
    cs = ax.contour(PH, TH, Z, levels=lv)
    ax.clabel(cs, inline=True, fontsize=7, fmt="%g")

    ax.set_theta_zero_location("E")
    ax.set_theta_direction(-1)
    ax.set_rlim(0, np.deg2rad(max(thetas_deg)))
    ax.set_title(title, fontsize=9)
    fig.tight_layout()
    fig.savefig(out_path, dpi=220)
    plt.close(fig)


def _solid_angle_fraction_over_threshold(thetas_deg, phis_deg, CR, thr=100.0):
    """
    Approximate fraction of solid angle (within the simulated theta/phi grid)
    where CR > thr, using weights ~ sin(theta) dtheta dphi.
    """
    import numpy as np
    th = np.deg2rad(np.array(thetas_deg, dtype=float))
    ph = np.deg2rad(np.array(phis_deg, dtype=float))

    # dtheta, dphi (assume uniform)
    if len(th) >= 2:
        dth = float(np.mean(np.diff(th)))
    else:
        dth = 1.0
    if len(ph) >= 2:
        dph = float(np.mean(np.diff(ph)))
    else:
        dph = 1.0

    Wth = np.sin(th) * dth * dph  # per-theta ring weight per phi step
    W = Wth[:, None] * np.ones((len(th), len(ph)))

    mask = (np.array(CR, dtype=float) > float(thr))
    num = float(np.sum(W[mask]))
    den = float(np.sum(W))
    return (num / den) if den > 0 else float("nan")


def run_Ascale_sweep_check_cr100(out_dir="asweep_cr100_contour",
                                 A_scales=(0.8, 1.0, 1.2, 1.5, 1.75, 2.0, 2.3),
                                 dC_um=None,
                                 pol_in=0.0, pol_out=0.0,
                                 relA=0.5, lc_rel=1.0,
                                 case_name="matched",
                                 wl_keys=("B", "G", "R"),
                                 thr=100.0,
                                 cr_cap=None):
    """
    Sweep A-plate thickness scale and confirm that the region CR>thr expands/shrinks.

    - Uses the same stack builder (build_stack_realistic) and the same rotation model:
        pol_in/out, relA(L=U), lc_rel_to_inpol_deg.
    - Produces ISO contour-line plots (no fill) for each A_scale.
    - Prints and returns a list with the CR>thr solid-angle fraction.
    """
    import numpy as np
    from pathlib import Path

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Dispersion case selection
    if case_name.lower().startswith("match"):
        dn_map = DN_SCALE_MATCHED
    elif case_name.lower().startswith("mismatch"):
        dn_map = DN_SCALE_MISMATCHED
    else:
        raise ValueError("case_name must be 'matched' or 'mismatched'")

    # Apply globals used by _ne_no_for_wl() and Tleak
    global DN_SCALE, WL_KEYS
    DN_SCALE = dict(dn_map)
    WL_KEYS = tuple(wl_keys)

    c1, c2 = pol_axes(pol_in, pol_out)

    results = []
    for A_scale in A_scales:
        stack = build_stack_realistic(
            dC_um=dC_um, A_scale=float(A_scale),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
            rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
            lc_rel_to_inpol_deg=float(lc_rel),
        )

        thetas, phis, CR = compute_CR_grid(stack, c1, c2, theta_max=THETA_MAX, dtheta=DTHETA, dphi=DPHI)
        frac = _solid_angle_fraction_over_threshold(thetas, phis, CR, thr=float(thr))

        # ISO contour lines
        labelC = "No_C" if dC_um is None else f"C_d{float(dC_um):.1f}um"
        title = (f"{case_name} | {''.join(wl_keys)} | {labelC}\n"
                 f"A_scale={float(A_scale):.2f}, thr={float(thr):g}\n"
                 f"pol_in/out={pol_in:g}/{pol_out:g}, relA={relA:g}, lc_rel={lc_rel:g}\n"
                 f"Frac[CR>{thr:g}]≈{frac:.4f}")
        out_png = out_dir / f"ISO_contour_{case_name}_{labelC}_A{float(A_scale):.2f}_thr{float(thr):g}.png"
        _iso_contour_lines_polar(thetas, phis, CR, title, out_png, cr_cap=cr_cap)

        results.append({
            "A_scale": float(A_scale),
            "C_um": None if dC_um is None else float(dC_um),
            "case": case_name,
            "wl_keys": list(wl_keys),
            "thr": float(thr),
            "frac_CR_gt_thr": float(frac),
            "plot": str(out_png)
        })

    # Print summary and a simple "expand/shrink" check
    print("\n=== A-scale sweep: fraction of region CR>%.1f (solid-angle weighted) ===" % float(thr))
    for r in results:
        c_label = "None" if r["C_um"] is None else f"{r['C_um']:.1f}"
        print(f"A_scale={r['A_scale']:.2f}, C={c_label}: frac={r['frac_CR_gt_thr']:.4f}  -> {Path(r['plot']).name}")

    # Check if it changes (not all equal)
    fracs = [r["frac_CR_gt_thr"] for r in results]
    if max(fracs) - min(fracs) < 1e-6:
        print("NOTE: fractions are (almost) identical across A_scales under this configuration.")
    else:
        print("OK: fractions vary with A_scale (region expands/shrinks).")

    # Save manifest for convenience
    (out_dir / "manifest.json").write_text(
        __import__("json").dumps(results, indent=2, ensure_ascii=False), encoding="utf-8"
    )
    print(f"Saved: {out_dir / 'manifest.json'}")
    return results



# ============================================================
# Added: Grid sweep over (A_scale list) x (C thickness list)
# ============================================================
def run_Ascale_C_grid_check(out_dir="agrid_cgrid_cr100_contour",
                            A_scales=(0.5, 1.0, 1.5, 2.0),
                            C_list=(-0.5, 0.0, 0.5),
                            pol_in=0.0, pol_out=0.0,
                            relA=0.5, lc_rel=1.0,
                            case_name="matched",
                            wl_keys=("B","G","R"),
                            thr=100.0,
                            cr_cap=None):
    """
    For each C thickness in C_list and A_scale in A_scales:
      - compute ISO CR grid (theta/phi) and
      - compute solid-angle-weighted fraction where CR>thr
      - save contour-line ISO plot (no fill)
    Also saves a manifest.json and summary.csv in out_dir.
    """
    from pathlib import Path
    import json, csv

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    all_results = []
    for C_um in C_list:
        dC_um = None if (C_um is None) else float(C_um)
        sub = out_dir / (f"C_{dC_um:+.2f}um" if dC_um is not None else "C_None")
        sub.mkdir(parents=True, exist_ok=True)
        res = run_Ascale_sweep_check_cr100(
            out_dir=str(sub),
            A_scales=tuple(A_scales),
            dC_um=dC_um,
            pol_in=pol_in, pol_out=pol_out,
            relA=relA, lc_rel=lc_rel,
            case_name=case_name,
            wl_keys=wl_keys,
            thr=thr,
            cr_cap=cr_cap
        )
        for r in res:
            r2 = dict(r)
            r2["C_um"] = dC_um
            all_results.append(r2)

    # Save a combined manifest
    (out_dir / "manifest_all.json").write_text(
        json.dumps(all_results, indent=2, ensure_ascii=False),
        encoding="utf-8"
    )

    # Save a compact summary CSV
    csv_path = out_dir / "summary.csv"
    fields = ["case", "wl_keys", "thr", "C_um", "A_scale", "frac_CR_gt_thr", "plot"]
    with csv_path.open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        for r in all_results:
            w.writerow({
                "case": r.get("case"),
                "wl_keys": "".join(r.get("wl_keys", [])),
                "thr": r.get("thr"),
                "C_um": r.get("C_um"),
                "A_scale": r.get("A_scale"),
                "frac_CR_gt_thr": r.get("frac_CR_gt_thr"),
                "plot": r.get("plot"),
            })

    # Print summary table to stdout
    print("\n=== Summary (fraction of region CR>%.1f) ===" % float(thr))
    # sort by C then A
    all_sorted = sorted(all_results, key=lambda x: (x["C_um"], x["A_scale"]))
    for r in all_sorted:
        print(f"C={r['C_um']:+.2f}um, A={r['A_scale']:.2f} -> frac={r['frac_CR_gt_thr']:.4f}")

    print(f"\nSaved combined manifest: {out_dir/'manifest_all.json'}")
    print(f"Saved summary CSV      : {csv_path}")
    return all_results



# ============================================================
# Added: pol_in sweep (fixed A_scale and C) to confirm ISO distortion
# ============================================================
def _phi_distortion_metric(thetas_deg, phis_deg, CR, cr_cap=1e5):
    """
    Simple distortion metric: average (over theta) of std(log10(CR)) over phi.
    Larger => more phi-anisotropy / "distortion" in polar iso contours.
    """
    import numpy as np
    Z = np.array(CR, dtype=float)
    if cr_cap is not None:
        Z = np.minimum(Z, float(cr_cap))
    # avoid log(0)
    L = np.log10(np.maximum(Z, 1.0))
    # std over phi for each theta, then average over theta (excluding theta=0 optionally)
    std_phi = np.std(L, axis=1)
    return float(np.mean(std_phi))


def run_pol_in_distortion_check(out_dir="pol_in_distortion_check",
                                pol_in_list=(0.0, 0.2, 0.5, 1.0, 2.0),
                                A_scale=2.0,
                                C_um=-0.5,
                                pol_out=0.0,
                                relA=0.5,
                                lc_rel=1.0,
                                case_name="matched",
                                wl_keys=("B","G","R"),
                                thr=100.0,
                                cr_cap=None):
    """
    Fix A_scale and C thickness, then sweep pol_in and generate ISO contour-line plots.
    Also computes a simple phi-anisotropy metric to confirm "distortion".

    Requested default:
      A_scale=2.0, C_um=-0.5
    """
    from pathlib import Path
    import json
    import numpy as np

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Dispersion case selection
    if case_name.lower().startswith("match"):
        dn_map = DN_SCALE_MATCHED
    elif case_name.lower().startswith("mismatch"):
        dn_map = DN_SCALE_MISMATCHED
    else:
        raise ValueError("case_name must be 'matched' or 'mismatched'")

    # Apply globals
    global DN_SCALE, WL_KEYS
    DN_SCALE = dict(dn_map)
    WL_KEYS = tuple(wl_keys)

    results = []
    dC_um = float(C_um)

    for pol_in in pol_in_list:
        c1, c2 = pol_axes(float(pol_in), float(pol_out))
        stack = build_stack_realistic(
            dC_um=dC_um, A_scale=float(A_scale),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
            rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
            lc_rel_to_inpol_deg=float(lc_rel),
        )
        thetas, phis, CR = compute_CR_grid(stack, c1, c2, theta_max=THETA_MAX, dtheta=DTHETA, dphi=DPHI)

        frac = _solid_angle_fraction_over_threshold(thetas, phis, CR, thr=float(thr))
        metric = _phi_distortion_metric(thetas, phis, CR, cr_cap=cr_cap)

        title = (f"{case_name} | {''.join(wl_keys)} | C={dC_um:+.2f}um | A={float(A_scale):.2f}\n"
                 f"pol_in={float(pol_in):.2f}deg, pol_out={float(pol_out):.2f}deg, relA={float(relA):.2f}, lc_rel={float(lc_rel):.2f}\n"
                 f"Frac[CR>{thr:g}]≈{frac:.4f}, phi-std(log10CR)≈{metric:.4f}")
        out_png = out_dir / f"ISO_contour_pol_in_{float(pol_in):.2f}deg_C{dC_um:+.2f}um_A{float(A_scale):.2f}.png"
        _iso_contour_lines_polar(thetas, phis, CR, title, out_png, cr_cap=cr_cap)

        results.append({
            "pol_in_deg": float(pol_in),
            "pol_out_deg": float(pol_out),
            "A_scale": float(A_scale),
            "C_um": float(dC_um),
            "case": case_name,
            "wl_keys": list(wl_keys),
            "thr": float(thr),
            "frac_CR_gt_thr": float(frac),
            "phi_std_log10CR": float(metric),
            "plot": str(out_png),
        })

    # Save manifest
    (out_dir / "manifest.json").write_text(
        json.dumps(results, indent=2, ensure_ascii=False), encoding="utf-8"
    )

    print("\n=== pol_in sweep distortion check ===")
    for r in results:
        print(f"pol_in={r['pol_in_deg']:.2f} deg -> frac(CR>{thr:g})={r['frac_CR_gt_thr']:.4f}, phi_std_log10CR={r['phi_std_log10CR']:.4f} | {Path(r['plot']).name}")
    print(f"Saved: {out_dir/'manifest.json'}")
    return results

def run_verification_demo_repro(out_dir="verification_demo_repro",
                                dC_list=(None, 1.0),
                                pol_in=0.0, pol_out=0.0,
                                relA=0.5, lc_rel=1.0,
                                lc_rel_to_inPOL=1.0,  # alias; kept for clarity
                                Agrid=None,
                                dphi_demo=10.0,
                                theta_demo=0.0,
                                make_iso_plots=True,
                                iso_use_contour_lines=True,
                                iso_cr_cap=None,
                                iso_theta_max=None,
                                iso_dtheta=None,
                                iso_dphi=None):
    """
    Reproduce the original printed demo results, then optionally save ISO plots.

    IMPORTANT: This routine matches the original 'compare_matched_mismatched_with_plots' demo definition:
      - Best A at GREEN in matched dispersion
      - WHITE = avg Tleak over B/G/R (i.e., WL_KEYS=("B","G","R") in Tleak_stack_scalar)
      - CR is computed from Tleak via CR_from_Tleak, then averaged over phi at theta=0

    Parameters allow you to match conditions exactly.
    """
    import numpy as np
    from pathlib import Path

    if Agrid is None:
        Agrid = np.linspace(0.2, 3.0, 57)

    # iso grid defaults from globals if not given
    if iso_theta_max is None: iso_theta_max = THETA_MAX
    if iso_dtheta is None:    iso_dtheta    = DTHETA
    if iso_dphi is None:      iso_dphi      = DPHI

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    def cr0_theta0_phiavg_by_Tleak(stack, c1, c2, wl_keys, dn_map):
        global WL_KEYS, DN_SCALE
        WL_KEYS = tuple(wl_keys)
        DN_SCALE = dict(dn_map)

        phis = np.arange(0.0, 360.0 + 1e-12, float(dphi_demo))
        CRs = []
        for phi in phis:
            T = Tleak_stack_scalar(float(theta_demo), float(phi), stack, c1, c2)
            CRs.append(CR_from_Tleak(T))
        return float(np.mean(CRs))

    def find_bestA_green_matched(dC_um):
        c1, c2 = pol_axes(float(pol_in), float(pol_out))
        bestA, bestCRG = None, -1.0
        for A in Agrid:
            stack = build_stack_realistic(
                dC_um=dC_um, A_scale=float(A),
                tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
                pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
                rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
                lc_rel_to_inpol_deg=float(lc_rel),
            )
            crg = cr0_theta0_phiavg_by_Tleak(stack, c1, c2, ("G",), DN_SCALE_MATCHED)
            if crg > bestCRG:
                bestCRG, bestA = crg, float(A)
        return bestA, bestCRG

    # Choose plotting function (contour lines if available)
    use_contour = bool(iso_use_contour_lines) and ("_iso_contour_lines_polar" in globals())

    results = []
    for dC_um in dC_list:
        labelC = "No_C" if dC_um is None else f"C_d{float(dC_um):.1f}um"

        # 1) bestA at GREEN (matched)
        bestA, bestCRG = find_bestA_green_matched(dC_um)

        # 2) CR0_WHITE at bestA for matched/mismatched (demo definition)
        c1, c2 = pol_axes(float(pol_in), float(pol_out))
        stack_best = build_stack_realistic(
            dC_um=dC_um, A_scale=float(bestA),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
            rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
            lc_rel_to_inpol_deg=float(lc_rel),
        )
        crw_match = cr0_theta0_phiavg_by_Tleak(stack_best, c1, c2, ("B","G","R"), DN_SCALE_MATCHED)
        crw_mis   = cr0_theta0_phiavg_by_Tleak(stack_best, c1, c2, ("B","G","R"), DN_SCALE_MISMATCHED)
        ratio = crw_mis / crw_match if crw_match > 0 else float("nan")

        # Print in the same style as the original demo
        print(f"\n== Dispersion mismatch demo (theta={theta_demo:g}, WHITE=avg Tleak over B/G/R) ===")
        print(f"Fixed rotations: pol_in={pol_in:.1f}deg, pol_out={pol_out:.1f}deg, rel_LA=rel_UA={relA:.1f}deg, LC_rel_to_inPOL={lc_rel:.1f}deg")
        print(f"[{labelC}] Best A_scale at GREEN (matched case): A_scale = {bestA:.2f} (CR0_G ≈ {bestCRG:.1f})")
        print(f"[{labelC}] CR0_WHITE (matched dispersion)    : {crw_match:.1f}")
        print(f"[{labelC}] CR0_WHITE (mismatched dispersion) : {crw_mis:.1f}")
        print(f"[{labelC}] Ratio mismatch/match              : {ratio:.3f}")

        # 3) Optional ISO plots (WHITE) at bestA
        plot_paths = {}
        if make_iso_plots:
            for case_name, dn_map in [("matched", DN_SCALE_MATCHED), ("mismatched", DN_SCALE_MISMATCHED)]:
                global DN_SCALE, WL_KEYS
                DN_SCALE = dict(dn_map)
                WL_KEYS = ("B","G","R")

                c1p, c2p = pol_axes(float(pol_in), float(pol_out))
                stack = build_stack_realistic(
                    dC_um=dC_um, A_scale=float(bestA),
                    tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
                    pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
                    rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
                    lc_rel_to_inpol_deg=float(lc_rel),
                )
                thetas, phis, CR = compute_CR_grid(stack, c1p, c2p, theta_max=iso_theta_max, dtheta=iso_dtheta, dphi=iso_dphi)
                # CR0 from grid (for reference)
                _, cr0_mean_grid, _, _ = compute_CR0_stats(thetas, CR)

                title = (f"{case_name} | WHITE | {labelC}\n"
                         f"bestA(G@theta0)={bestA:.2f} (CR0_G≈{bestCRG:.1f})\n"
                         f"CR0_WHITE(demo) match={crw_match:.1f} mis={crw_mis:.1f} ratio={ratio:.3f}\n"
                         f"CR0_WHITE(grid mean)={cr0_mean_grid:.1f}\n"
                         f"pol_in/out={pol_in:g}/{pol_out:g}, relA={relA:g}, lc_rel={lc_rel:g}")

                out_png = out_dir / f"ISO_demoRepro_{case_name}_WHITE_{labelC}_bestA{bestA:.2f}.png"
                if use_contour:
                    _iso_contour_lines_polar(thetas, phis, CR, title, out_png, cr_cap=iso_cr_cap)
                else:
                    # fallback to existing filled plot function in the original script
                    plot_isocontrast_polar(thetas, phis, CR, title, out_png)
                plot_paths[case_name] = str(out_png)

        results.append({
            "C_um": None if dC_um is None else float(dC_um),
            "bestA": float(bestA),
            "CR0_G": float(bestCRG),
            "CR0_WHITE_matched": float(crw_match),
            "CR0_WHITE_mismatched": float(crw_mis),
            "ratio": float(ratio),
            "plots": plot_paths
        })

    # Save a JSON summary for reproducibility
    (out_dir / "demo_repro_summary.json").write_text(
        __import__("json").dumps(results, indent=2, ensure_ascii=False), encoding="utf-8"
    )
    print(f"\nSaved: {out_dir/'demo_repro_summary.json'}")
    return results

if __name__ == "__main__":
    #run_verification_iso_plots()

    run_verification_demo_repro(
        out_dir="demo_repro_check_C1p0",
        dC_list=(1.0,),
        pol_in=0.0, pol_out=0.0,
        relA=0.5, lc_rel=1.0,
        dphi_demo=10.0, theta_demo=0.0,
        make_iso_plots=True,
        iso_use_contour_lines=True
    )

# ============================================================
# Added: A-scale sweep to verify CR>threshold region expands/shrinks
#        + ISO contour (no fill) for readability
# ============================================================
def _iso_contour_lines_polar(thetas_deg, phis_deg, CR, title, out_path,
                             levels=(100, 250, 500, 750, 1000, 1500, 2000, 3000, 5000, 10000, 20000, 50000),
                             cr_cap=None):
    """
    Polar ISO plot with contour *lines* (no fill).
    thetas_deg: 1D degrees (radius)
    phis_deg  : 1D degrees (angle)
    CR        : 2D [theta, phi]
    """
    import numpy as np
    import matplotlib.pyplot as plt

    TH, PH = np.meshgrid(np.deg2rad(thetas_deg), np.deg2rad(phis_deg), indexing="ij")
    Z = np.array(CR, dtype=float)
    if cr_cap is not None:
        Z = np.minimum(Z, float(cr_cap))

    # Trim levels to cap if needed
    lv = list(levels)
    if cr_cap is not None:
        lv = sorted(set([x for x in lv if x <= cr_cap] + [float(cr_cap)]))

    fig = plt.figure(figsize=(6.2, 6.2))
    ax = fig.add_subplot(111, projection="polar")
    cs = ax.contour(PH, TH, Z, levels=lv)
    ax.clabel(cs, inline=True, fontsize=7, fmt="%g")

    ax.set_theta_zero_location("E")
    ax.set_theta_direction(-1)
    ax.set_rlim(0, np.deg2rad(max(thetas_deg)))
    ax.set_title(title, fontsize=9)
    fig.tight_layout()
    fig.savefig(out_path, dpi=220)
    plt.close(fig)


def _solid_angle_fraction_over_threshold(thetas_deg, phis_deg, CR, thr=100.0):
    """
    Approximate fraction of solid angle (within the simulated theta/phi grid)
    where CR > thr, using weights ~ sin(theta) dtheta dphi.
    """
    import numpy as np
    th = np.deg2rad(np.array(thetas_deg, dtype=float))
    ph = np.deg2rad(np.array(phis_deg, dtype=float))

    # dtheta, dphi (assume uniform)
    if len(th) >= 2:
        dth = float(np.mean(np.diff(th)))
    else:
        dth = 1.0
    if len(ph) >= 2:
        dph = float(np.mean(np.diff(ph)))
    else:
        dph = 1.0

    Wth = np.sin(th) * dth * dph  # per-theta ring weight per phi step
    W = Wth[:, None] * np.ones((len(th), len(ph)))

    mask = (np.array(CR, dtype=float) > float(thr))
    num = float(np.sum(W[mask]))
    den = float(np.sum(W))
    return (num / den) if den > 0 else float("nan")


def run_Ascale_sweep_check_cr100(out_dir="asweep_cr100_contour",
                                 A_scales=(0.8, 1.0, 1.2, 1.5, 1.75, 2.0, 2.3),
                                 dC_um=None,
                                 pol_in=0.0, pol_out=0.0,
                                 relA=0.5, lc_rel=1.0,
                                 case_name="matched",
                                 wl_keys=("B", "G", "R"),
                                 thr=100.0,
                                 cr_cap=None):
    """
    Sweep A-plate thickness scale and confirm that the region CR>thr expands/shrinks.

    - Uses the same stack builder (build_stack_realistic) and the same rotation model:
        pol_in/out, relA(L=U), lc_rel_to_inpol_deg.
    - Produces ISO contour-line plots (no fill) for each A_scale.
    - Prints and returns a list with the CR>thr solid-angle fraction.
    """
    import numpy as np
    from pathlib import Path

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Dispersion case selection
    if case_name.lower().startswith("match"):
        dn_map = DN_SCALE_MATCHED
    elif case_name.lower().startswith("mismatch"):
        dn_map = DN_SCALE_MISMATCHED
    else:
        raise ValueError("case_name must be 'matched' or 'mismatched'")

    # Apply globals used by _ne_no_for_wl() and Tleak
    global DN_SCALE, WL_KEYS
    DN_SCALE = dict(dn_map)
    WL_KEYS = tuple(wl_keys)

    c1, c2 = pol_axes(pol_in, pol_out)

    results = []
    for A_scale in A_scales:
        stack = build_stack_realistic(
            dC_um=dC_um, A_scale=float(A_scale),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
            rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
            lc_rel_to_inpol_deg=float(lc_rel),
        )

        thetas, phis, CR = compute_CR_grid(stack, c1, c2, theta_max=THETA_MAX, dtheta=DTHETA, dphi=DPHI)
        frac = _solid_angle_fraction_over_threshold(thetas, phis, CR, thr=float(thr))

        # ISO contour lines
        labelC = "No_C" if dC_um is None else f"C_d{float(dC_um):.1f}um"
        title = (f"{case_name} | {''.join(wl_keys)} | {labelC}\n"
                 f"A_scale={float(A_scale):.2f}, thr={float(thr):g}\n"
                 f"pol_in/out={pol_in:g}/{pol_out:g}, relA={relA:g}, lc_rel={lc_rel:g}\n"
                 f"Frac[CR>{thr:g}]≈{frac:.4f}")
        out_png = out_dir / f"ISO_contour_{case_name}_{labelC}_A{float(A_scale):.2f}_thr{float(thr):g}.png"
        _iso_contour_lines_polar(thetas, phis, CR, title, out_png, cr_cap=cr_cap)

        results.append({
            "A_scale": float(A_scale),
            "C_um": None if dC_um is None else float(dC_um),
            "case": case_name,
            "wl_keys": list(wl_keys),
            "thr": float(thr),
            "frac_CR_gt_thr": float(frac),
            "plot": str(out_png)
        })

    # Print summary and a simple "expand/shrink" check
    print("\n=== A-scale sweep: fraction of region CR>%.1f (solid-angle weighted) ===" % float(thr))
    for r in results:
        c_label = "None" if r["C_um"] is None else f"{r['C_um']:.1f}"
        print(f"A_scale={r['A_scale']:.2f}, C={c_label}: frac={r['frac_CR_gt_thr']:.4f}  -> {Path(r['plot']).name}")

    # Check if it changes (not all equal)
    fracs = [r["frac_CR_gt_thr"] for r in results]
    if max(fracs) - min(fracs) < 1e-6:
        print("NOTE: fractions are (almost) identical across A_scales under this configuration.")
    else:
        print("OK: fractions vary with A_scale (region expands/shrinks).")

    # Save manifest for convenience
    (out_dir / "manifest.json").write_text(
        __import__("json").dumps(results, indent=2, ensure_ascii=False), encoding="utf-8"
    )
    print(f"Saved: {out_dir / 'manifest.json'}")
    return results



# ============================================================
# Added: Grid sweep over (A_scale list) x (C thickness list)
# ============================================================
def run_Ascale_C_grid_check(out_dir="agrid_cgrid_cr100_contour",
                            A_scales=(0.5, 1.0, 1.5, 2.0),
                            C_list=(-0.5, 0.0, 0.5),
                            pol_in=0.0, pol_out=0.0,
                            relA=0.5, lc_rel=1.0,
                            case_name="matched",
                            wl_keys=("B","G","R"),
                            thr=100.0,
                            cr_cap=None):
    """
    For each C thickness in C_list and A_scale in A_scales:
      - compute ISO CR grid (theta/phi) and
      - compute solid-angle-weighted fraction where CR>thr
      - save contour-line ISO plot (no fill)
    Also saves a manifest.json and summary.csv in out_dir.
    """
    from pathlib import Path
    import json, csv

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    all_results = []
    for C_um in C_list:
        dC_um = None if (C_um is None) else float(C_um)
        sub = out_dir / (f"C_{dC_um:+.2f}um" if dC_um is not None else "C_None")
        sub.mkdir(parents=True, exist_ok=True)
        res = run_Ascale_sweep_check_cr100(
            out_dir=str(sub),
            A_scales=tuple(A_scales),
            dC_um=dC_um,
            pol_in=pol_in, pol_out=pol_out,
            relA=relA, lc_rel=lc_rel,
            case_name=case_name,
            wl_keys=wl_keys,
            thr=thr,
            cr_cap=cr_cap
        )
        for r in res:
            r2 = dict(r)
            r2["C_um"] = dC_um
            all_results.append(r2)

    # Save a combined manifest
    (out_dir / "manifest_all.json").write_text(
        json.dumps(all_results, indent=2, ensure_ascii=False),
        encoding="utf-8"
    )

    # Save a compact summary CSV
    csv_path = out_dir / "summary.csv"
    fields = ["case", "wl_keys", "thr", "C_um", "A_scale", "frac_CR_gt_thr", "plot"]
    with csv_path.open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        for r in all_results:
            w.writerow({
                "case": r.get("case"),
                "wl_keys": "".join(r.get("wl_keys", [])),
                "thr": r.get("thr"),
                "C_um": r.get("C_um"),
                "A_scale": r.get("A_scale"),
                "frac_CR_gt_thr": r.get("frac_CR_gt_thr"),
                "plot": r.get("plot"),
            })

    # Print summary table to stdout
    print("\n=== Summary (fraction of region CR>%.1f) ===" % float(thr))
    # sort by C then A
    all_sorted = sorted(all_results, key=lambda x: (x["C_um"], x["A_scale"]))
    for r in all_sorted:
        print(f"C={r['C_um']:+.2f}um, A={r['A_scale']:.2f} -> frac={r['frac_CR_gt_thr']:.4f}")

    print(f"\nSaved combined manifest: {out_dir/'manifest_all.json'}")
    print(f"Saved summary CSV      : {csv_path}")
    return all_results



# ============================================================
# Added: pol_in sweep (fixed A_scale and C) to confirm ISO distortion
# ============================================================
def _phi_distortion_metric(thetas_deg, phis_deg, CR, cr_cap=1e5):
    """
    Simple distortion metric: average (over theta) of std(log10(CR)) over phi.
    Larger => more phi-anisotropy / "distortion" in polar iso contours.
    """
    import numpy as np
    Z = np.array(CR, dtype=float)
    if cr_cap is not None:
        Z = np.minimum(Z, float(cr_cap))
    # avoid log(0)
    L = np.log10(np.maximum(Z, 1.0))
    # std over phi for each theta, then average over theta (excluding theta=0 optionally)
    std_phi = np.std(L, axis=1)
    return float(np.mean(std_phi))


def run_pol_in_distortion_check(out_dir="pol_in_distortion_check",
                                pol_in_list=(0.0, 0.2, 0.5, 1.0, 2.0),
                                A_scale=2.0,
                                C_um=-0.5,
                                pol_out=0.0,
                                relA=0.5,
                                lc_rel=1.0,
                                case_name="matched",
                                wl_keys=("B","G","R"),
                                thr=100.0,
                                cr_cap=None):
    """
    Fix A_scale and C thickness, then sweep pol_in and generate ISO contour-line plots.
    Also computes a simple phi-anisotropy metric to confirm "distortion".

    Requested default:
      A_scale=2.0, C_um=-0.5
    """
    from pathlib import Path
    import json
    import numpy as np

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Dispersion case selection
    if case_name.lower().startswith("match"):
        dn_map = DN_SCALE_MATCHED
    elif case_name.lower().startswith("mismatch"):
        dn_map = DN_SCALE_MISMATCHED
    else:
        raise ValueError("case_name must be 'matched' or 'mismatched'")

    # Apply globals
    global DN_SCALE, WL_KEYS
    DN_SCALE = dict(dn_map)
    WL_KEYS = tuple(wl_keys)

    results = []
    dC_um = float(C_um)

    for pol_in in pol_in_list:
        c1, c2 = pol_axes(float(pol_in), float(pol_out))
        stack = build_stack_realistic(
            dC_um=dC_um, A_scale=float(A_scale),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
            rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
            lc_rel_to_inpol_deg=float(lc_rel),
        )
        thetas, phis, CR = compute_CR_grid(stack, c1, c2, theta_max=THETA_MAX, dtheta=DTHETA, dphi=DPHI)

        frac = _solid_angle_fraction_over_threshold(thetas, phis, CR, thr=float(thr))
        metric = _phi_distortion_metric(thetas, phis, CR, cr_cap=cr_cap)

        title = (f"{case_name} | {''.join(wl_keys)} | C={dC_um:+.2f}um | A={float(A_scale):.2f}\n"
                 f"pol_in={float(pol_in):.2f}deg, pol_out={float(pol_out):.2f}deg, relA={float(relA):.2f}, lc_rel={float(lc_rel):.2f}\n"
                 f"Frac[CR>{thr:g}]≈{frac:.4f}, phi-std(log10CR)≈{metric:.4f}")
        out_png = out_dir / f"ISO_contour_pol_in_{float(pol_in):.2f}deg_C{dC_um:+.2f}um_A{float(A_scale):.2f}.png"
        _iso_contour_lines_polar(thetas, phis, CR, title, out_png, cr_cap=cr_cap)

        results.append({
            "pol_in_deg": float(pol_in),
            "pol_out_deg": float(pol_out),
            "A_scale": float(A_scale),
            "C_um": float(dC_um),
            "case": case_name,
            "wl_keys": list(wl_keys),
            "thr": float(thr),
            "frac_CR_gt_thr": float(frac),
            "phi_std_log10CR": float(metric),
            "plot": str(out_png),
        })

    # Save manifest
    (out_dir / "manifest.json").write_text(
        json.dumps(results, indent=2, ensure_ascii=False), encoding="utf-8"
    )

    print("\n=== pol_in sweep distortion check ===")
    for r in results:
        print(f"pol_in={r['pol_in_deg']:.2f} deg -> frac(CR>{thr:g})={r['frac_CR_gt_thr']:.4f}, phi_std_log10CR={r['phi_std_log10CR']:.4f} | {Path(r['plot']).name}")
    print(f"Saved: {out_dir/'manifest.json'}")
    return results

if __name__ == "__main__":
    run_verification_iso_plots()

    # --- After verification ISO: A-scale x C sweep (CR>100 region) ---
    run_Ascale_C_grid_check(
        out_dir="agrid_cgrid_cr100_contour_Cplus1p0",
        A_scales=(0.5, 1.0, 1.5, 2.0),
        C_list=(-0.5, 0.0, 0.5, 1.0),
        pol_in=0.0, pol_out=0.0,
        relA=0.5, lc_rel=1.0,
        case_name="matched",
        wl_keys=("B", "G", "R"),
        thr=100.0,
        cr_cap=None
    )
    run_pol_in_distortion_check(
        out_dir="pol_in_distortion_check_A2p0_Cm0p5",
        pol_in_list=(0.0, 0.2, 0.5, 1.0, 2.0),
        A_scale=2.0,
        C_um=-0.5
    )

def run_verification_demo_repro(out_dir="verification_demo_repro",
                                dC_list=(None, 1.0),
                                pol_in=0.0, pol_out=0.0,
                                relA=0.5, lc_rel=1.0,
                                lc_rel_to_inPOL=1.0,  # alias; kept for clarity
                                Agrid=None,
                                dphi_demo=10.0,
                                theta_demo=0.0,
                                make_iso_plots=True,
                                iso_use_contour_lines=True,
                                iso_cr_cap=None,
                                iso_theta_max=None,
                                iso_dtheta=None,
                                iso_dphi=None):
    """
    Reproduce the original printed demo results, then optionally save ISO plots.

    IMPORTANT: This routine matches the original 'compare_matched_mismatched_with_plots' demo definition:
      - Best A at GREEN in matched dispersion
      - WHITE = avg Tleak over B/G/R (i.e., WL_KEYS=("B","G","R") in Tleak_stack_scalar)
      - CR is computed from Tleak via CR_from_Tleak, then averaged over phi at theta=0

    Parameters allow you to match conditions exactly.
    """
    import numpy as np
    from pathlib import Path

    if Agrid is None:
        Agrid = np.linspace(0.2, 3.0, 57)

    # iso grid defaults from globals if not given
    if iso_theta_max is None: iso_theta_max = THETA_MAX
    if iso_dtheta is None:    iso_dtheta    = DTHETA
    if iso_dphi is None:      iso_dphi      = DPHI

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    def cr0_theta0_phiavg_by_Tleak(stack, c1, c2, wl_keys, dn_map):
        global WL_KEYS, DN_SCALE
        WL_KEYS = tuple(wl_keys)
        DN_SCALE = dict(dn_map)

        phis = np.arange(0.0, 360.0 + 1e-12, float(dphi_demo))
        CRs = []
        for phi in phis:
            T = Tleak_stack_scalar(float(theta_demo), float(phi), stack, c1, c2)
            CRs.append(CR_from_Tleak(T))
        return float(np.mean(CRs))

    def find_bestA_green_matched(dC_um):
        c1, c2 = pol_axes(float(pol_in), float(pol_out))
        bestA, bestCRG = None, -1.0
        for A in Agrid:
            stack = build_stack_realistic(
                dC_um=dC_um, A_scale=float(A),
                tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
                pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
                rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
                lc_rel_to_inpol_deg=float(lc_rel),
            )
            crg = cr0_theta0_phiavg_by_Tleak(stack, c1, c2, ("G",), DN_SCALE_MATCHED)
            if crg > bestCRG:
                bestCRG, bestA = crg, float(A)
        return bestA, bestCRG

    # Choose plotting function (contour lines if available)
    use_contour = bool(iso_use_contour_lines) and ("_iso_contour_lines_polar" in globals())

    results = []
    for dC_um in dC_list:
        labelC = "No_C" if dC_um is None else f"C_d{float(dC_um):.1f}um"

        # 1) bestA at GREEN (matched)
        bestA, bestCRG = find_bestA_green_matched(dC_um)

        # 2) CR0_WHITE at bestA for matched/mismatched (demo definition)
        c1, c2 = pol_axes(float(pol_in), float(pol_out))
        stack_best = build_stack_realistic(
            dC_um=dC_um, A_scale=float(bestA),
            tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
            pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
            rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
            lc_rel_to_inpol_deg=float(lc_rel),
        )
        crw_match = cr0_theta0_phiavg_by_Tleak(stack_best, c1, c2, ("B","G","R"), DN_SCALE_MATCHED)
        crw_mis   = cr0_theta0_phiavg_by_Tleak(stack_best, c1, c2, ("B","G","R"), DN_SCALE_MISMATCHED)
        ratio = crw_mis / crw_match if crw_match > 0 else float("nan")

        # Print in the same style as the original demo
        print(f"\n== Dispersion mismatch demo (theta={theta_demo:g}, WHITE=avg Tleak over B/G/R) ===")
        print(f"Fixed rotations: pol_in={pol_in:.1f}deg, pol_out={pol_out:.1f}deg, rel_LA=rel_UA={relA:.1f}deg, LC_rel_to_inPOL={lc_rel:.1f}deg")
        print(f"[{labelC}] Best A_scale at GREEN (matched case): A_scale = {bestA:.2f} (CR0_G ≈ {bestCRG:.1f})")
        print(f"[{labelC}] CR0_WHITE (matched dispersion)    : {crw_match:.1f}")
        print(f"[{labelC}] CR0_WHITE (mismatched dispersion) : {crw_mis:.1f}")
        print(f"[{labelC}] Ratio mismatch/match              : {ratio:.3f}")

        # 3) Optional ISO plots (WHITE) at bestA
        plot_paths = {}
        if make_iso_plots:
            for case_name, dn_map in [("matched", DN_SCALE_MATCHED), ("mismatched", DN_SCALE_MISMATCHED)]:
                global DN_SCALE, WL_KEYS
                DN_SCALE = dict(dn_map)
                WL_KEYS = ("B","G","R")

                c1p, c2p = pol_axes(float(pol_in), float(pol_out))
                stack = build_stack_realistic(
                    dC_um=dC_um, A_scale=float(bestA),
                    tac_repeat=int(TAC_REPEATS[0]), tac_um=float(TAC_UM_CASES[0]), dn_tac=float(DN_TAC_CASES[0]),
                    pol_pair_rot_in_deg=float(pol_in), pol_pair_rot_out_deg=float(pol_out),
                    rel_rot_LA_deg=float(relA), rel_rot_UA_deg=float(relA),
                    lc_rel_to_inpol_deg=float(lc_rel),
                )
                thetas, phis, CR = compute_CR_grid(stack, c1p, c2p, theta_max=iso_theta_max, dtheta=iso_dtheta, dphi=iso_dphi)
                # CR0 from grid (for reference)
                _, cr0_mean_grid, _, _ = compute_CR0_stats(thetas, CR)

                title = (f"{case_name} | WHITE | {labelC}\n"
                         f"bestA(G@theta0)={bestA:.2f} (CR0_G≈{bestCRG:.1f})\n"
                         f"CR0_WHITE(demo) match={crw_match:.1f} mis={crw_mis:.1f} ratio={ratio:.3f}\n"
                         f"CR0_WHITE(grid mean)={cr0_mean_grid:.1f}\n"
                         f"pol_in/out={pol_in:g}/{pol_out:g}, relA={relA:g}, lc_rel={lc_rel:g}")

                out_png = out_dir / f"ISO_demoRepro_{case_name}_WHITE_{labelC}_bestA{bestA:.2f}.png"
                if use_contour:
                    _iso_contour_lines_polar(thetas, phis, CR, title, out_png, cr_cap=iso_cr_cap)
                else:
                    # fallback to existing filled plot function in the original script
                    plot_isocontrast_polar(thetas, phis, CR, title, out_png)
                plot_paths[case_name] = str(out_png)

        results.append({
            "C_um": None if dC_um is None else float(dC_um),
            "bestA": float(bestA),
            "CR0_G": float(bestCRG),
            "CR0_WHITE_matched": float(crw_match),
            "CR0_WHITE_mismatched": float(crw_mis),
            "ratio": float(ratio),
            "plots": plot_paths
        })

    # Save a JSON summary for reproducibility
    (out_dir / "demo_repro_summary.json").write_text(
        __import__("json").dumps(results, indent=2, ensure_ascii=False), encoding="utf-8"
    )
    print(f"\nSaved: {out_dir/'demo_repro_summary.json'}")
    return results



from google.colab import drive
drive.mount('/content/drive')